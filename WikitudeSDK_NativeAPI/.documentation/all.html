<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Wikitude SDK Android Native API 1.2.0 Documentation</title>
    <link type="text/css" rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lato:300,400,700">

    <link type="text/css" rel="stylesheet" href="css/reset.css">
    <link type="text/css" rel="stylesheet" href="css/docs.css">
    <link type="text/css" rel="stylesheet" href="css/print.css" media="print">
    <link type="text/css" rel="stylesheet" href="css/github.min.css">
    <link type="text/css" rel="stylesheet" href="css/default.min.css">
    <link type="text/css" rel="stylesheet" href="css/lightbox.min-0.5.1.css">
    <link type="text/css" rel="stylesheet" href="css/jquery.treemenu.css">

    
    <script type="text/javascript" src="js/jquery-2.1.4.min.js"></script>
    <script type="text/javascript" src="js/highlight-8.6.min.js"></script>
    <script type="text/javascript" src="js/lunr.min-0.5.11.js"></script>
    <script type="text/javascript" src="js/deprecated.js"></script>
    <script type="text/javascript" src="js/lightbox.min-0.5.1.js"></script>
    <script type="text/javascript" src="js/jquery.treemenu.js"></script>

    <script type="text/javascript">
        $(document).ready(function() {
            // Every image referenced from a Markdown document
            $("#content img").each(function() {
                // Let's put a caption if there is one
                if($(this).attr("alt"))
                    $(this).wrap('<figure class="image"></figure>')
                        .after('<figcaption>'+$(this).attr("alt")+'</figcaption>');
                });
        });
    </script>


    <script type="text/javascript">
    hljs.initHighlightingOnLoad();
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            if(isVersionDeprecated())
                document.getElementById('deprecatedNote').style.display='block';
                document.getElementById("documentationSelect").onchange = function() {
                var selectedOption = this.value;
                 console.log(selectedOption);
                 window.top.location.href = "http://www.wikitude.com/developer/documentation/" + selectedOption;
                }
        });
    </script>

</head>
<body>
    <div id="page">
        <a name="top" />
         

<div id="sidebar">
    <div id="topnav">
    <img src="images/150610_WT_SDK_Logo.png">
    <h1><a href="">Documentation</a></h1>
    <h2>Wikitude SDK Android Native API</h2>
    
    <div id="version">version: 1.2.0</div>
    

    
    <select id="documentationSelect">
        
            <option value="android"  > Android </option>
        
            <option value="androidnative"  selected > Android Native API </option>
        
            <option value="phonegap"  > Cordova </option>
        
            <option value="epson"  > Epson </option>
        
            <option value="ios"  > iOS </option>
        
            <option value="iOSnative"  > iOS Native API </option>
        
            <option value="glass"  > Google Glass </option>
        
            <option value="vuzix"  > Vuzix </option>
        
            <option value="htmlcss"  > Web </option>
        
            <option value="titanium"  > Titanium </option>
        
            <option value="unity"  > Unity </option>
        
            <option value="xamarin"  > Xamarin </option>
        
            <option value=""  > --- </option>
        
            <option value="cloudrecognition"  > Cloud Recognition </option>
        
            <option value="targetsapi"  > Targets API </option>
        
    </select>
    

    <div id="deprecatedNote" class="warning" style="display:none;">Note you are viewing the documentation of a deprecated version. Please check <a href="http://www.wikitude.com/developer/documentation">www.wikitude.com/developer/documentation</a></div>

    </div>

    <input id="showNav" class="toggleNav" type="checkbox">
    <label class="showNavLbl" for="showNav">Show Navigation</label>
    <label class="hideNavLbl" for="showNav">Hide Navigation</label>

    <div id="mainnav">
    <form action="search.html"><input id="search" type="text" placeholder="Search documentation" name="q" /></form>
    <nav id="toc">
        
    <ul>
    
        <li>
            <a href="gettingstartedandroidnative.html#getting-started">Getting started</a>
            
                
    <ul>
    
        <li>
            <a href="setupguideandroidnative.html#setup-guide-android-native-api">Setup Guide Android Native API</a>
            
        </li>
    
        <li>
            <a href="supporteddevicesandroid.html#supported-android-devices">Supported Android Devices</a>
            
        </li>
    
        <li>
            <a href="triallicense.html#how-to-obtain-a-free-trial-license">How to obtain a free trial license</a>
            
        </li>
    
        <li>
            <a href="triallicense.html#where-should-i-enter-the-license-key">Where should I enter the license key</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="samplesnative.html#examples">Examples</a>
            
                
    <ul>
    
        <li>
            <a href="clientrecognitionnative.html#client-recognition">Client Recognition</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionnative.html#cloud-recognition">Cloud Recognition</a>
            
        </li>
    
        <li>
            <a href="renderingnative.html#rendering">Rendering</a>
            
        </li>
    
        <li>
            <a href="pluginsapi.html#plugins-api">Plugins API</a>
            
        </li>
    
        <li>
            <a href="hardwarecontrolnative.html#camera-controls">Camera Controls</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="toolsnative.html#wikitude-2d-tracking">Wikitude 2D Tracking</a>
            
                
    <ul>
    
        <li>
            <a href="targetmanagement.html#target-management">Target Management</a>
            
        </li>
    
        <li>
            <a href="targetguide.html#best-practice-for-target-images">Best practice for target images</a>
            
        </li>
    
        <li>
            <a href="targetimages.html#target-images">Target Images</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="3dtracking.html#wikitude-3d-tracking">Wikitude 3D Tracking</a>
            
                
    <ul>
    
        <li>
            <a href="3dtracking.html#about-wikitude-3d-tracking">About Wikitude 3D Tracking</a>
            
        </li>
    
        <li>
            <a href="3dtracking.html#license">License</a>
            
        </li>
    
        <li>
            <a href="3dtracking.html#limitations-of-the-wikitude-3d-tracking-beta">Limitations of the Wikitude 3D Tracking Beta</a>
            
        </li>
    
        <li>
            <a href="trackingmap3d.html#creating-3d-tracking-maps">Creating 3D Tracking Maps</a>
            
        </li>
    
        <li>
            <a href="3dtracking-guidelines.html#3d-tracking-guidelines-and-best-practices">3D Tracking Guidelines and best practices</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#wikitude-cloud-recognition">Wikitude Cloud Recognition</a>
            
                
    <ul>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#general-definitions">General Definitions</a>
            
        </li>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#getting-started-with-the-cloud-recognition-service">Getting Started with the Cloud Recognition Service</a>
            
        </li>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#authentication">Authentication</a>
            
        </li>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#quota-and-limits">Quota and Limits</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#your-first-target-collections">Your first Target Collections</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#add-target-images">Add Target Images</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#generate-a-cloud-archive">Generate a Cloud Archive</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#generate-a-wtc-file">Generate a WTC file</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#additional-calls">Additional calls</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="migration-androidnative.html#migrate">Migrate</a>
            
                
    <ul>
    
        <li>
            <a href="migration-androidnative.html#migrate-from-10-to-11">Migrate from 1.0 to 1.1</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="referenceandroidnative.html#reference">Reference</a>
            
                
    <ul>
    
        <li>
            <a href="referenceandroidnative.html#android-native-api-javadocs">Android Native API JavaDocs</a>
            
        </li>
    
        <li>
            <a href="referenceandroidnative.html#cloud-recognition-manager-api">Cloud Recognition Manager API</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-android-native-api-release-notes">Wikitude SDK Android Native API Release Notes</a>
            
                
    <ul>
    
        <li>
            <a href="changelog.html#wikitude-sdk-5">Wikitude SDK 5</a>
            
        </li>
    
</ul>

            
        </li>
    
</ul>

    </nav>
    
    <nav id="links">
        <ul>
            
        </ul>
    </nav>
    
    </div>
</div>
        <div id="content">
            <h1 id="getting-started">Getting started</h1>
<p class='intro' markdown='1'>Welcome to the Wikitude SDK. This document is designed to help you from your very first steps with the Wikitude SDK all the way through to advanced concepts and examples for developing your augmented reality project.</p>

<h3 id="recommended-usage-of-this-documentation">Recommended Usage of this Documentation</h3>
<p>The documentation is arranged in a way to guide you through the various steps in your development process. We recommend  following each of the steps outlined below and reading the documentation in the order displayed.</p>
<div class="bigNumbers" markdown='1'>
<div class='number'>1</div>
<h4 id="-setup-your-project-setupguideandroidnative-html-"><a href="setupguideandroidnative.html">Setup your project</a></h4>
<p>In this section we describe the necessary steps to setup a project in a detailed guide.</p>
<div class='number'>2</div>
<h4 id="-view-the-samples-samplesnative-html-"><a href="samplesnative.html">View the samples</a></h4>
<p>All of the included samples are complete Android projects and apps. Browse through this section and get an idea of what the Wikitude SDK Native API is capable of. The relevant parts of the samples are described in more detail to highlight the applied concepts and patterns. These examples are designed to help you get off to a great start with the Wikitude SDK.</p>
<p>Viewing samples based on vision based augmented reality requires the corresponding reference images. All of them are available directly in the description of the sample or available as a collection <a href="targetimages.html">on this page</a>, which you can either view on the screen or print.
</div></p>
<h3 id="the-wikitude-native-sdk-augmented-reality-for-your-own-app">The Wikitude Native SDK - Augmented Reality for your own app</h3>
<p>The Wikitude Native SDK is a software library and framework for mobile apps used to create augmented reality experiences. </p>
<p>As opposed to the Wikitude SDK which uses a JavaScript API the Wikitude Native SDK allows to create your AR experiences directly in Java and OpenGL.</p>
<h3 id="architecture-of-the-wikitude-sdk">Architecture of the Wikitude SDK</h3>
<p><img src="images/WikitudeSDK_architecture_v5.png" alt=""></p>
<p>The image above shows the different components of the Wikitude SDK and possible approaches for creating augmented reality apps. Each of these approaches is based on a certain development environments (IDE) and platforms:</p>
<ul>
<li><strong>Computer Vision Engine:</strong> The computer vision engine is a core component of the Wikitude SDK and used by all platforms. It is not directly accessible, but wrapped either by the Native API or the JavaScript API.</li>
<li><strong>Wikitude SDK  - Native API:</strong> Provides access to the Wikitude computer vision engine natively for Android (Java) and iOS (ObjC). It also can load plugins via the Wikitude Plugins API. (NOTE: Wikitude SDK plugins have nothing to do with the Cordova or Unity Plugin concept.)</li>
<li><strong>Wikitude SDK  - JavaScript API:</strong> Allows to build augmented reality worlds on basis of HTML and JavaScript. It is available for Android and iOS. The JavaScript API provides access to the functionality of the computer vision engine, location based AR, the Plugins API and dedicated rendering functionality.</li>
<li><strong>Wikitude SDK  - Plugins API:</strong> An API to connect your own plugins to the Wikitude SDK.</li>
<li><strong>Wikitude SDK  - Cordova Plugin:</strong> On top of the JavaScript API the Cordova plugin allows to use the Wikitude SDK in combination with Apache Cordova.</li>
<li><strong>Wikitude SDK  - Titanium Module:</strong> On top of the JavaScript API the Titanium module allows to use the Wikitude SDK in combination with Titanium.</li>
<li><strong>Wikitude SDK  - Unity Plugin:</strong> On top of the Native API the Unity plugin allows to use the Wikitude SDK in combination with Unity.</li>
<li><strong>Wikitude SDK  - Xamarin Component:</strong> On top of the JavaScript API the Cordova plugin allows to use the Wikitude SDK in combination with Xamarin.</li>
</ul>
<h3 id="the-wikitude-developer-portal">The Wikitude Developer Portal</h3>
<p>The <a href="http://www.wikitude.com" target="_top">Wikitude Developer Section</a> should be your first stop when you have specific development related questions. The portal hosts a very active <a href="http://www.wikitude.com/developer/developer-forum" target="_top">Developer Community Forum</a> where Wikitude staff members are constantly assisting other developers with helpful tips and advice. A <a href="http://www.wikitude.com/developer/knowledge-base" target="_top">Knowledge Base</a> helps with various questions.</p>
<h3 id="feedback-and-contact">Feedback and Contact</h3>
<p>We are always interested in your feedback and suggestions how we can improve this documentation. Please use the <a href="http://www.wikitude.com/contact" target="_top">contact form</a> on our website or visit us on <a href="https://google.com/+WikitudeDevs" target="_top">Google+</a> or <a href="http://www.facebook.com/WIKITUDE" target="_top">Facebook</a></p>

<h2 id="setup-guide-android-native-api">Setup Guide Android Native API</h2>
<h3 id="project-setup">Project Setup</h3>
<ul>
<li><p>Create a new <a href="http://developer.android.com/training/basics/firstapp/creating-project.html" target="_top">Android Studio Application Project</a> (There is also a working SampleProject bundled in this SDK, where all these steps are already made)</p>
</li>
<li><p>Copy the file <code>libs/wikitude_native_sdk.aar</code> into the libs folder of your module. (project root/app/libs)</p>
</li>
<li><p>Open <code>build.gradle (Module: app)</code>, add the <code>wikitudesdk.aar</code> as a dependency and tell gradle to search the libs folder, like in the code below.</p>
</li>
</ul>
<pre><code>android {
    ...
}

dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    compile (name: &#39;wikitudesdk_native_sdk&#39;, ext:&#39;aar&#39;)
    ...
}

repositories {
    flatDir{
        dirs &#39;libs&#39;
    }
}
</code></pre><ul>
<li>If you already purchased a license, please set the applicationId to the package name you provided us with.</li>
</ul>
<pre><code class="lang-xml">    defaultConfig {
        applicationId &quot;xxxx&quot;
    }
</code></pre>
<ul>
<li>Add the following permissions and features to your AndroidManifest.xml</li>
</ul>
<pre><code class="lang-xml">    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;

    &lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;

    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;
</code></pre>
<ul>
<li>Also in the Android manifest define following config changes for the activity which adds the OpenGL view</li>
</ul>
<pre><code class="lang-xml">        &lt;activity
            android:name=&quot;YOUR_PACKAGE_NAME.YOUR_ACTIVITY_NAME&quot;
            android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; /&gt;
</code></pre>
<ul>
<li>Read this chapter on how to <a href="triallicense.html">obtain a free trial key</a>, which you will later pass to the Wikitude Native SDK.</li>
</ul>

<h2 id="supported-android-devices">Supported Android Devices</h2>
<p>Wikitude SDK is running on devices fulfilling the following requirements:</p>
<table>
<tr>
<th></th>
<th style="width:42%;">Sensor-based AR (Geo-AR)</th>
<th style="width:42%;">Image recognition and tracking</th>
</tr>
<tr>
<td><a name="supporteddevicesandroid"></a><strong>Android</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Android 4.0+ (API Level 14+)</li>
 <li>Compass</li>
 <li>GPS and / or network positioning</li>
 <li>Accelerometer</li>
 <li><a href="http://developer.android.com/guide/practices/screens_support.html" target="_top">High resolution devices (hdpi)</a></li>
 <li>Rear-facing camera</li>
 <li><a href="http://developer.android.com/guide/topics/graphics/opengl.html" target="_top">OpenGL 2.0</a></li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Android 4.0+ (API Level 14+)</li>
  <li><a href="http://developer.android.com/guide/practices/screens_support.html" target="_top">High resolution devices (hdpi)</a></li>
   <li>Rear-facing camera</li>
 <li>Devices with a capable CPU (armv7a and NEON support) e.g.</li>
 <ul><li>Samsung Galaxy S2 or newer</li>
 <li>Nexus 4 or newer</li>
 <li>Nexus 10 (2012) or newer</li>
</ul>
 </ul>

</td>
</tr>

</table>

<p>Requirements for other operating systems and platforms are listed in <a href="supporteddevices.html">this overview</a>.</p>

<h4 id="supported-devices">Supported Devices</h4>
<p>Wikitude SDK is running on devices fulfilling the following requirements:</p>
<table>
<tr>
<th></th>
<th style="width:42%;">Sensor-based AR (Geo-AR)</th>
<th style="width:42%;">Image recognition and tracking</th>
</tr>
<tr>
<td><a name="supporteddevicesandroid"></a><strong>Android</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Android 4.0+ (API Level 14+)</li>
 <li>Compass</li>
 <li>GPS and / or network positioning</li>
 <li>Accelerometer</li>
 <li><a href="http://developer.android.com/guide/practices/screens_support.html" target="_top">High resolution devices (hdpi)</a></li>
 <li>Rear-facing camera</li>
 <li><a href="http://developer.android.com/guide/topics/graphics/opengl.html" target="_top">OpenGL 2.0</a></li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Android 4.0+ (API Level 14+)</li>
  <li><a href="http://developer.android.com/guide/practices/screens_support.html" target="_top">High resolution devices (hdpi)</a></li>
   <li>Rear-facing camera</li>
 <li>Devices with a capable CPU (armv7a and NEON support) e.g.</li>
 <ul><li>Samsung Galaxy S2 or newer</li>
 <li>Nexus 4 or newer</li>
 <li>Nexus 10 (2012) or newer</li>
</ul>
 </ul>

</td>
</tr>
<tr>
<td><a name="supporteddevicesepson"></a><strong>Epson</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Epson Moverio BT-200</li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Epson Moverio BT-200</li>
 </ul>
</td>
</tr>
<tr>
<td><a name="supporteddevicesglass"></a><strong>Google Glass</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Google Glass</li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Google Glass</li>
 </ul>
</td>
</tr>

<tr>
<td><a name="supporteddevicesios"></a><strong>iOS</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Devices running iOS 7.0  and up</li>
 <li>Compass</li>
 <li>GPS and / or network positioning</li>
 <li>Accelerometer</li>
 <li>Rear-facing camera</li>
 </ul>
 </td>
<td style="vertical-align:top;">
 <ul>
  <li>Devices running iOS 7.0  and up</li>
  <li>Rear-facing camera</li>
 <li>Devices with a capable CPU (minimum Apple A4 SoC) e.g.</li>
 <ul><li>iPhone 4 or newer</li>
 <li>iPad2 or newer</li>
 <li>iPod Touch 5th gen</li></ul>
 </ul>
</td>
</tr>
<tr>
<td><a name="supporteddevicesvuzix"></a><strong>Vuzix</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Vuzix M100</li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Vuzix M100</li>
 </ul>
</td>
</tr>
</table>

<h2 id="how-to-obtain-a-free-trial-license">How to obtain a free trial license</h2>
<p>The Wikitude SDK requires a valid license key to be able to run properly. An empty or missing license key will block the augmented reality view from showing any meaningful content. You will see a watermark across the screen with the words <code>License Key Missing</code>. All JavaScript API calls will be ignored and not interpreted.</p>
<p>When downloading the Wikitude SDK you will be forwarded to the <a href="http://www.wikitude.com/developer/licenses">license generation page</a>, where a trial license key is automatically generated for you. </p>
<p><img src="images/trial_key_license_page.png" alt=""></p>
<p>Copy the key into your app, which will unlock the trial mode of the Wikitude SDK. The trial mode of the Wikitude SDK contains the full feature set of the Wikitude SDK but will show a <code>Trial</code> watermark across the screen.</p>
<p>Each trial license key is valid for every application ID on every operating system. You can use the same trial license key in multiple apps. </p>
<h2 id="where-should-i-enter-the-license-key">Where should I enter the license key</h2>
<h3 id="android-native-api">Android Native API</h3>
<p>To use the Wikitude Android SDK you need to provide a valid license key to the <code>onCreate</code> lifecycle method of the Wikitude SDK object. </p>
<p>Create a <code>StartupConfiguration</code> object and pass it the license as a string and then call the <code>onCreate(getApplicationContext(), startupConfiguration)</code> method. </p>
<pre><code>     WikitudeSDKStartupConfiguration startupConfiguration = new WikitudeSDKStartupConfiguration(WikitudeSDKConstants.WIKITUDE_SDK_KEY, CameraSettings.CameraPosition.BACK, CameraSettings.CameraFocusMode.CONTINUOUS);
        _wikitudeSDK.onCreate(getApplicationContext(), startupConfiguration);
</code></pre>
<h1 id="examples">Examples</h1>
<p>The following examples should give you an overview of the capabilities offered by the Wikitude SDK. Each sample is capable of running without modifications on all supported platforms. </p>
<p>The Sample App is a fully functional sample project either for Android or iOS. You can easily import it into Android Studio or Xcode and work from there. The user interface is kept very simple and shows a list to select the sample you are interested.</p>
<h3 id="wikitude-sdk-android-native-api-examples">Wikitude SDK Android Native API Examples</h3>
<p>This section describes the <code>Native SDK Sample</code> project in detail and highlights the main features and use-cases of the Wikitude SDK.
The project is part of the SDK bundle and is an Android Studio project, ready to run on any of the supported Android devices.</p>
<p><em>Note: You cannot run the Wikitude SDK project on an Android Emulator due to OpenGL restrictions.</em></p>
<p>Run through the setup guide, install the sample project on your device and scroll through the sample list.</p>
<h3 id="setup">Setup</h3>
<ul>
<li>Download latest <a href="https://developer.android.com/sdk/index.html" target="_top">Android SDK</a> through the Android Studio Bundle (either Mac OS or Windows)</li>
<li>From the main menu bar, select   <code>File</code> -&gt; <code>Open</code> which will open the import wizard.</li>
<li>Navigate to the <code>NativeSDKExamples</code> project folder from the package you downloaded from us.</li>
<li>Click <code>Choose</code> to open the Example project.  </li>
<li>Use an Android device that has all hard- and software requirements (see <a href="SupportedDevicesAndroid.html">Supported Devices</a>).</a></li>
<li>Enable USB debugging on your device.</li>
<li>Plug in the device via USB.</li>
<li>Back in Android Studio click on the green &quot;Play&quot;-Button to install the Example application on your device.</li>
</ul>

<h2 id="client-recognition">Client Recognition</h2>
<p>This example shows how to recognize images in the viewfinder and overlay it with images. </p>
<p>For a better understanding, here are some terms that will be used in the following and other section of this documentation related to vision-based augmented reality.</p>
<ul>
<li><p><strong>Target</strong>: A 2D target image and its associated extracted data that is used by the tracker to recognize an image.</p>
</li>
<li><p><strong>Target Collection</strong>: An archive storing a collection of 2D targets that can be recognized by the tracker. A target collection can hold up to 1000 targets. Target collections are stored as <code>.wtc</code> files</p>
</li>
<li><p><strong>3D Tracking Map</strong>: A tracking map is the equivalent of a target for 3D tracking. The map contains the relevant characteristics of a three-dimensional object. In order to recognize and track 3D objects you need to record a map first and then load this map. Maps are stored as <code>.wtm</code> files. </p>
</li>
<li><p><strong>ClientTracker</strong>: The tracker analyzes the live camera image and detects the 2D targets stored in its associated target collection. Multiple trackers can be created, however only one tracker can be active for recognition at any given time.</p>
</li>
</ul>
<p><a id="SimpleClientTrackingAndroid"></a></p>
<h3 id="simple-2d-client-tracking-android">Simple 2D Client Tracking Android</h3>
<p>In this section we will go through the code of the <code>SimpleClientTrackingActivity</code>, which you can find in the example application under the package <code>com.wikitude.samples.recognition.client</code>. We will discuss general concepts on how to use the Wikitude Native SDK as we go along, please don&#39;t skip this section even if you are for example only interested in cloud recognition.</p>
<p>The <code>WikitudeSDK</code> class is structured to be used in a standard Android activity and to make use of the activities life cycle events. We will use interfaces to communicate to the <code>WikitudeSDK</code> which type of rendering method we would like to use and to provide the necessary callbacks for Client- and Cloud-Trackers.</p>
<p>First let us have a look at the declaration of the activity class. </p>
<pre><code class="lang-java">public class SimpleClientTrackingActivity extends Activity implements ClientTrackerEventListener, ExternalRendering {
...
}
</code></pre>
<p>We subclass the standard Android activity and implement the interfaces <code>ClientTrackerEventListener</code> and <code>ExternalRendering</code>. Later on when we create the instance of the WikitudeSDK we will pass the <code>this</code> pointer of our activity to the WikitudeSDK constructor and this way indicate our chosen type of rendering. In this example we will use external rendering, for details on how to setup the rendering and the difference between internal and external rendering please read through the section on <a href="renderingnative.html">rendering</a>.</p>
<p>The next step we will take is create an instance of the <code>WikitudeSDK</code> class. This and the <code>StartupConfiguration</code> are the only objects you will need to create by yourself, every other object will be created by factory methods of the <code>WikitudeSDK</code> instance. </p>
<div class="warning"> 
IMPORTANT: Do not instantiate any other class out of the Wikitude Native SDK other than the WikitudeSDK and the WikitudeSDKStartupConfiguration.
</div>

<p>We are now going through each method of the <code>SimpleClientTrackingActivity</code> class, starting with <code>onCreate</code>. In the <code>onCreate</code> method we instantiate an instance of the <code>WikitudeSDK</code>, and an instance of the <code>WikitudeSDKStartupConfiguration</code>, which will hold our license key. If you do not have a license key yet, read this chapter on how to <a href="triallicense.html">obtain a free trial key</a>. After that we are ready to propagate the onCreate life cycle event to the Wikitude SDK. It is very important that you do propagate onCreate, onPause and onResume otherwise the Wikitude SDK won&#39;t be able to properly manage its resources which will lead to unexpected behavior.</p>
<p>After we called the WikitudeSDK onCreate method the SDK is initialized and we are now able to create a <code>ClientTracker</code>. To do that we get the <code>TrackerManager</code> from the <code>WikitudeSDK</code> instance and call <code>create2dClientTracker</code> passing the url to the WTC file. Since we are loading an asset on the device we indicate that by starting the url with the string file:///android_asset/ and add the path to the file starting from the asset root directory.</p>
<p>To get notified when the Tracker finished loading, recognized a target and so on we register the Activity which implements ClientTrackerEventListener as a Listener on the newly created Tracker.</p>
<pre><code class="lang-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    _wikitudeSDK = new WikitudeSDK(this);
    WikitudeSDKStartupConfiguration startupConfiguration = new WikitudeSDKStartupConfiguration(WikitudeSDKConstants.WIKITUDE_SDK_KEY);
    _wikitudeSDK.onCreate(getApplicationContext(), startupConfiguration);
    ClientTracker tracker = _wikitudeSDK.getTrackerManager().create2dClientTrackerFromUrl(&quot;file:///android_asset/magazine.wtc&quot;);
    tracker.registerTrackerEventListener(this);
}
</code></pre>
<p>The next important method to look at is the <code>onRenderExtensionCreated</code> method. Since we decided to use the external rendering functionality by implementing <code>ExternalRendering</code>, the <code>WikitudeSDK</code> provides us with a RenderExtension. The RenderExtension interface exposes the same methods as the standard <code>GLSurfaceView.Renderer</code>. In your custom <code>GLSurfaceView.Renderer</code> the first thing to do in every method is to always call the same method on the provided RenderExtension. To be able to that we pass the RenderExtension to the constructor of our <code>Renderer</code>, create our <code>SurfaceView</code>, initialize a <code>Driver</code> and set our <code>SurfaceView</code> as our content view.</p>
<pre><code class="lang-java">@Override
public void onRenderExtensionCreated(final RenderExtension renderExtension_) {
    _glRenderer = new GLRenderer(renderExtension_);
    _view = new CustomSurfaceView(getApplicationContext(), _glRenderer);
    _driver = new Driver(_view, 30);
    setContentView(_view);
}
</code></pre>
<p>Next we will have a look at the <code>ClientTrackerEventListener</code> interface. The <code>onErrorLoading</code> method will be called like the name suggest when the Wikitude SDK wasn&#39;t able to load the client tracker. The most likely cause of this to happen would be that either the path to the WTC file was incorrect or the WTC was corrupted. The <code>onTrackerFinishedLoading</code> method will be called once when the tracker was successfully loaded. When the client tracker first recognizes a target it will call <code>onTargetRecognized</code> providing you with the recognized target name. When the client tracker starts tracking this target it will call <code>onTracking</code> continuously until it loses the target and finishes tracking with a call to <code>onTargetLost</code>.</p>
<p>The <code>RecognizedTarget</code> object provided in the <code>onTracking</code> method contains information about the tracked target like the name, the distance to the target and most importantly the matrices which describe where on the camera frame the target was found. Since we need this information to draw on the target we pass the object to our renderer in the &#39;onTracking&#39; method and remove it when we lose the target in the <code>onTargetLost</code> method.</p>
<pre><code class="lang-java">@Override
public void onErrorLoading(final ClientTracker clientTracker_, final String errorMessage_) {
    Log.v(TAG, &quot;onErrorLoading: &quot; + errorMessage_);
}

@Override
public void onTrackerFinishedLoading(final ClientTracker clientTracker_, final String trackerFilePath_) {

}

@Override
public void onTargetRecognized(final ClientTracker tracker_, final String targetName_) {

}

@Override
public void onTracking(final ClientTracker tracker_, final RecognizedTarget recognizedTarget_) {
    _glRenderer.setCurrentlyRecognizedTarget(recognizedTarget_);
}

@Override
public void onTargetLost(final ClientTracker tracker_, final String targetName_) {
    _glRenderer.setCurrentlyRecognizedTarget(null);
}
</code></pre>
<p><a id="ExtendedClientTracking"></a></p>
<h3 id="2d-extended-client-tracking-android">2D Extended Client Tracking Android</h3>
<p>Extended tracking is an optional mode you can set for each target separately. In this mode the Wikitude SDK will try to continue to scan the environment of the user even if the original target image is not in view anymore. So the tracking extends beyond the limits of the original target image. The performance of this feature depends on various factors like computing power of the device, background texture and objects.</p>
<p>Based on the previous sample, to enable Extended Tracking for a tracker you need to provide a String array which defines which targets should be extended. In this sample we simply set a wildcard <code>*</code> so that all targets in this tracker are extended. </p>
<pre><code>ClientTracker tracker = _wikitudeSDK.getTrackerManager().create2dClientTracker(&quot;file:///android_asset/magazine.wtc&quot;, new String[]{&quot;*&quot;});
</code></pre><h3 id="3d-client-tracking-android">3D Client Tracking Android</h3>
<p>In this example we will take a look at how to use the Wikitude <code>TrackingMapRecorder</code> and 3D ClientTracker to enable 3D Tracking. If you haven&#39;t already done so please read through the first section on 2D Tracking before continuing here. Essential concepts like how to setup rendering or how to use a Wikitude Tracker are explained there and won&#39;t be repeated here. Similar if you don&#39;t already know why we need to record a Tracking Map or what to expect from 3D Tracking in general please read through the <a href="3dtracking.html">introduction to 3D tracking</a>.</p>
<p>After we setup our activity to use <code>ExternalRendering</code> we will initialize the user interface in the <code>onRenderExtensionCreated</code> callback method. Let&#39;s look at the first lines of code below.</p>
<pre><code class="lang-java">@Override
public void onRenderExtensionCreated(final RenderExtension renderExtension_) {

    ... setup GL view ...

        showStartDialog();

    ...
}

private void showStartDialog() {
    AlertDialog.Builder builder = new AlertDialog.Builder(ClientTracking3DActivity.this);
    builder.setNegativeButton(&quot;Leave Example&quot;, new DialogInterface.OnClickListener() {
        ...
    });
    builder.setPositiveButton(&quot;Start Recording&quot;, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int id) {
            _wikitudeSDK.getTrackingMapRecorder().startRecording();
            _trackingQualityIndicator.setVisibility(View.VISIBLE);
            _stopButton.setVisibility(View.VISIBLE);
            _stopButton.setEnabled(true);
        }
    });

    ...

    dialog.show();
}
</code></pre>
<p>The first thing we do in the <code>onRenderExtensionCreated</code> method after setting up rendering is calling the private method <code>showStartDialog</code>. The purpose of the start dialog is to provide the user with some information about what he needs to do and a way to start the map recording. We activate the positive button of the AlertDialog by setting the title to <code>Start Recording</code> and passing an <code>OnClickListener</code>. In this <code>OnClickListener</code> we start the Tracking Map recording by getting the <code>TrackingMapRecorder</code> from the <code>WikitudeSDK</code> instance and calling <code>startRecording</code>. We also update the UI by setting the necessary components to visible. We will talk about what those components do later in this section.</p>
<pre><code class="lang-java">@Override
public void onRenderExtensionCreated(final RenderExtension renderExtension_) {

    ... setup GL view ...
    ... show start dialog ...

    _wikitudeSDK.getTrackingMapRecorder().registerTrackingMapRecorderEventListener(new TrackingMapRecorderEventListener() {
        @Override
        public void onFinishedSavingTrackingMap(File file) {
            ...
        }

        @Override
        public void onErrorSavingTrackingMap(String errorMessage) {
            ...
        }

        @Override
        public void onTrackingMapRecordingQualityChanged(final int oldTrackingQuality, final int newTrackingQuality) {
            ...
        }

        @Override
        public void onTrackingMapRecordingCanceled() {
            ...
        }
    });

    ...
</code></pre>
<p>The next thing we do in the <code>onRenderExtensionCreated</code> method is registering a <code>TrackingMapRecorderEventListener</code> by calling <code>registerTrackingMapRecorderEventListener</code> on the <code>TrackingMapRecorder</code> we get from the WikitudeSDK instance. The <code>TrackingMapRecorderEventListener</code> interface exposes several callbacks to us. In the following we will go through the implementation of each of them one by one, starting with the <code>onFinishedSavingTrackingMap</code> method.</p>
<pre><code class="lang-java">_wikitudeSDK.getTrackingMapRecorder().registerTrackingMapRecorderEventListener(new TrackingMapRecorderEventListener() {
    @Override
    public void onFinishedSavingTrackingMap(File file) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                saveMessage.setVisibility(View.INVISIBLE);
                _stopButton.setVisibility(View.INVISIBLE);
            }
        });
        _wikitudeSDK.getTrackerManager().create3dClientTracker(file.getAbsolutePath()).registerTrackerEventListener(ClientTracking3DActivity.this);
    }
    ...
}
</code></pre>
<p>The <code>onFinishedSavingTrackingMap</code> callback will be called when the <code>TrackingMapRecorder</code> successfully finished saving the recording to file. We will react to that fact by getting the UI ready for tracking by removing all visible UI components. After we cleared the UI we get the <code>TrackingManager</code> from the <code>WikitudeSDK</code> instance and create a new 3D ClientTracker by calling <code>create3dClientTracker</code> passing the path to the newly created Tracking Map file. As a result of this call the <code>WikitudeSDK</code> will pass back to us the <code>ClientTracker</code> instance it just created for us. We use it right away to register our Activity as a <code>TrackerEventListener</code>. The implementation of the <code>TrackerEventListener</code> callbacks is the same as in the first example of this chapter so we won&#39;t go into detail about it here.</p>
<pre><code class="lang-java">_wikitudeSDK.getTrackingMapRecorder().registerTrackingMapRecorderEventListener(new TrackingMapRecorderEventListener() {

    ...

    @Override
    public void onErrorSavingTrackingMap(String errorMessage) {
        Log.v(TAG, errorMessage);
    }

    ...
}
</code></pre>
<p>The second callback method of the <code>TrackingMapRecorderEventListener</code> is the <code>onErrorSavingTrackingMap</code>. This method will be called by the <code>TrackingMapRecorder</code> if there was an error saving the Tracking Map from memory to file. This could be for several reasons but since Tracking Maps can get quite large with longer recordings the most likely one is that there is not enough storage space left on the device. In this example we just log the error message but if you are using the <code>TrackingMapRecorder</code> in a production app, you probably want to react on the error in some way.</p>
<pre><code class="lang-java">_wikitudeSDK.getTrackingMapRecorder().registerTrackingMapRecorderEventListener(new TrackingMapRecorderEventListener() {

    ...

    @Override
    public void onTrackingMapRecordingQualityChanged(final int oldTrackingQuality, final int newTrackingQuality) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                _currentTrackingQuality = newTrackingQuality;
                switch (newTrackingQuality) {
                    case -1:
                        _trackingQualityIndicator.setBackgroundColor(Color.parseColor(&quot;#FF3420&quot;));
                        _trackingQualityIndicator.setText(R.string.tracking_quality_indicator_bad);
                        break;
                    case 0:
                        _trackingQualityIndicator.setBackgroundColor(Color.parseColor(&quot;#FFD900&quot;));
                        _trackingQualityIndicator.setText(R.string.tracking_quality_indicator_average);
                        break;
                    default:
                        _trackingQualityIndicator.setBackgroundColor(Color.parseColor(&quot;#6BFF00&quot;));
                        _trackingQualityIndicator.setText(R.string.tracking_quality_indicator_good);
                }
            }
        });
    }

    ...
}
</code></pre>
<p>Since it can be hard to tell when your recording reached sufficient quality to be used for tracking, the <code>TrackingMapRecorder</code> will update us in the <code>onTrackingMapRecordingQualityChanged</code> method about the current map status. It will pass <code>-1</code> if the least necessary quality isn&#39;t reached yet, <code>0</code> as soon as tracking with this map will be ok but not great and something higher than <code>0</code> when the desired quality was reached. We react to all three indications by setting the <code>trackingQualityIndicator</code> UI component to the appropriate state.</p>
<pre><code class="lang-java">_wikitudeSDK.getTrackingMapRecorder().registerTrackingMapRecorderEventListener(new TrackingMapRecorderEventListener() {

    ...

    @Override
    public void onTrackingMapRecordingCanceled() {
        showStartDialog();
    }

    ...
}
</code></pre>
<p>The last of the <code>TrackingMapRecorderEventListener</code> callbacks will be called by the <code>TrackingMapRecorder</code> after a recording was canceled. After you canceled a recording you will need to wait till this method is called to start a new map recording. This is exactly what we do in this example by showing the initial start dialog to the user.</p>
<pre><code class="lang-java">@Override
public void onRenderExtensionCreated(final RenderExtension renderExtension_) {
    ...

    _stopButton = (Button) findViewById(R.id.client_tracking_3d_stop_recording);
    _stopButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            _stopButton.setVisibility(View.INVISIBLE);
            _trackingQualityIndicator.setVisibility(View.INVISIBLE);
            if (_currentTrackingQuality &gt; 0) {
                saveMessage.setVisibility(View.VISIBLE);
                deleteTemporaryTrackingMap();
                _wikitudeSDK.getTrackingMapRecorder().stopRecording(TRACKING_MAP_FILENAME);
            } else {
                showConfirmStopDialog();
            }
        }
    });

    ...
}
</code></pre>
<p>After we implemented all TrackingMapRecorder callbacks the last thing we do in the <code>onRenderExtionsionCreated</code> method is implement the <code>OnClickListener</code> of the &quot;Stop Recording&quot; button. When the &quot;Stop Recording&quot; button is clicked the first thing we do is clear up the UI. Then we check if the last tracking quality indicator value was already high enough for the best possible tracking quality. If it was we show a save message to the user, clean up the last recording if there is one and stop and save the recording by getting the <code>TrackingMapRecorder</code> and calling <code>stopRecording</code> passing the name of the file the map should be stored in. Please note that you only need to pass the name of the file without any path information. All recordings will be save in external storage under <code>Android/data/com.wikitude.nativesdksampleapp/files</code>.</p>
<p>If the tracking quality indicator value indicates a bad or average recording quality we show the user a confirmation dialog, by calling the private method <code>showConfirmStopDialog</code>.</p>
<pre><code class="lang-java">private void showConfirmStopDialog() {
    AlertDialog.Builder builder = new AlertDialog.Builder(ClientTracking3DActivity.this);
    builder.setNegativeButton(&quot;Restart&quot;, new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            _wikitudeSDK.getTrackingMapRecorder().cancelRecording();
        }
    });
    builder.setPositiveButton(&quot;Continue&quot;, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int id) {
            deleteTemporaryTrackingMap();
            _wikitudeSDK.getTrackingMapRecorder().stopRecording(TRACKING_MAP_FILENAME);
        }
    });
    builder.setMessage(&quot;In order to experience a well working 3d tracking example, please continue recording until the quality indicator says &#39;Good&#39;.&quot;)
            .setTitle(&quot;Tracking Map quality not sufficient&quot;);
    AlertDialog dialog = builder.create();
    dialog.setCancelable(false);
    dialog.show();
}
</code></pre>
<p>In the confirm stop dialog we give the user the option to either restart the recording or continue to save the recording. If the user decides to restart we cancel the recording by calling <code>cancelRecording</code> on the <code>TrackingMapRecorder</code>. If the user decides to use the map anyway we stop the recording like above. </p>

<h2 id="cloud-recognition">Cloud Recognition</h2>
<p>This example shows how to recognize images on a cloud server and then overlay it with augmentations utilizing the <code>CloudTracker</code> class. </p>
<p>For a better understanding, here are some terms that will be used in the following and other sections of this documentation related to vision-based augmented reality.</p>
<ul>
<li><p><strong>Target</strong>: An image and its associated extracted data that is used to recognize an image.</p>
</li>
<li><p><strong>Target Collection</strong>: A group of <code>targets</code> that are searched together. Think of it as a directory, which contains all your images you want to search. The Wikitude SDK can work with two different sorts of <code>Target Collections</code></p>
<ul>
<li>On-device Target Collection: a static <code>wtc</code> file containing the extracted data of your images. Can consist of up to 1,000 images.</li>
<li>Cloud Target Collection: A target collection stored on the Wikitude server. See <code>Cloud Archive</code> below. Can consist of up to 50,000 images.</li>
</ul>
</li>
<li><p><strong>Cloud Archive</strong>: An archive stored on the server that is optimized for cloud-based recognition. It is generated from a <code>Target Collection</code> and is used in combination with <code>CloudTracker</code> . </p>
</li>
<li><p><strong>CloudTracker</strong>: Instead of analysing and computing the live camera feed directly on the device like the <code>ClientTracker</code>, the <code>CloudTracker</code> will send the image(s) taken by the camera to the Wikitude Cloud Recognition server. The server will then do the hard work of trying to match the image with your targets in the specified cloud archive. Beside the benefit of searching in large image database using the <code>CloudTracker</code>  instead of <code>ClientTracker</code>  has also a positive impact on the general performance in most cases. Especially when using a large target collection and on older devices.</p>
</li>
</ul>
<p>For both Cloud Recognition samples below we will use external rendering if you don&#39;t know what that means please go through the section on <a href="renderingnative.html">rendering</a> before starting here.</p>
<p>The <code>CloudTracker</code> is able to run in two modes, we call them on-click and continuous. In On-Click mode a single recognition cycle will be executed, in continuous mode the recognition will be started in a variable interval. You can find both examples discussed in the following in our sample application under the package <code>com.wikitude.recognition.cloud</code>.</p>
<h4 id="regional-server-endpoints">Regional server endpoints</h4>
<p>Before we get started please note that you have to choose which regional-distributed Wikitude server the SDK should contact.</p>
<p>The cloud recognition server region can be selected by calling <code>setCloudRecognitionServerRegion</code> of the <code>TrackerManager</code>. Every <code>CloudTracker</code> created after this call, will use the chosen region. In the following code snippet we will change the Cloud Recognition server location from the default setting of Europe to China.</p>
<pre><code class="lang-java">    _wikitudeSDK.getTrackerManager().setCloudRecognitionServerRegion(TrackerManager.ServerRegion.CHINA);
</code></pre>
<p><a id="OnClickCloudRecognition"></a></p>
<h3 id="on-click-cloud-recognition">On-Click Cloud Recognition</h3>
<p>We will now go through the class <code>OnClickCloudTrackingActivity</code> of our sample application, starting with the <code>onCreate</code> method. In <code>onCreate</code> after creating an instance of the <code>WikitudeSDK</code>, we obtain the <code>TrackerManager</code> and call <code>create2dCloudTracker</code> passing our authentication token and target collection id. On the <code>CloudTracker</code> instance returned by the <code>TrackerManager</code> we call <code>registerTrackerEventListener</code> passing <code>this</code> to register our activity as a listener for this particular <code>CloudTracker</code>. For this to work, we implemented <code>CloudTrackerEventListener</code> on our activity.</p>
<pre><code class="lang-java">public class OnClickCloudTrackingActivity extends Activity implements CloudTrackerEventListener, ExternalRendering {

    ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        _wikitudeSDK.onCreate(getApplicationContext(), startupConfiguration);
        _cloudTracker = _wikitudeSDK.getTrackerManager().create2dCloudTracker(&quot;b277eeadc6183ab57a83b07682b3ceba&quot;, &quot;54e4b9fe6134bb74351b2aa3&quot;);
        _cloudTracker.registerTrackerEventListener(this);
    }
</code></pre>
<p><code>CloudTrackerEventListener</code> defines callbacks which enable the <code>CloudTracker</code> to communicate its status. On one hand we receive notifications about the loading process and on the other hand we receive updates concerning the tracking process. Let&#39;s first have a look at the methods concerning the loading process. The method <code>onTrackerFinishedLoading</code> will be called, when the <code>CloudTracker</code> was successfully loaded and initialized. In this example we do not have a reason to react on that, but you could for example do some initializations to be ready when the <code>CloudTracker</code> recognizes a target. The <code>onTrackerLoadingError</code> method will be called when there was a problem loading the <code>CloudTracker</code>. We&#39;ll receive an errorMessage, containing more information about the problem. For debugging purposes we just log the error for now. In a real world project, were you already tested your app and know it won&#39;t be some small mistake like for example a wrong target collection id, you probably want to remove the log and for example try to load the <code>CloudTracker</code> again.</p>
<pre><code class="lang-java">
    @Override
    public void onTrackerFinishedLoading(final CloudTracker cloudTracker_) {
    }

    @Override
    public void onTrackerLoadingError(final CloudTracker cloudTracker_, final String errorMessage_) {
        Log.d(TAG, &quot;onTrackerLoadingError: &quot; + errorMessage_);
    }
</code></pre>
<p>We had a look at the loading process callbacks above. Now let&#39;s move on to the callbacks concerning the tracking process. The methods <code>onTargetRecognized</code> as well as <code>onRecognitionSuccessful</code> will be called when the <code>CloudTracker</code> first recognizes one of your targets. In this example we do not react on the <code>onTargetRecognized</code> call, because we do not care which of our targets were recognized, but again in a real world example you could prepare your renderer for the target to be tracked. The <code>onRecognitionSuccessful</code> method is unique to the <code>CloudTracker</code> and not available in the <code>ClientTracker</code> interface. It will be passed a <code>JSONObject</code> containing meta information you defined for this target when creating your Cloud Archive. For now we will just display the contents in a standard <code>Edittext</code> ui component so you can have a look.</p>
<p>After the call to <code>onTargetRecognized</code> the next calls will be to <code>onTracking</code>. On this calls the <code>CloudTracker</code> will pass an instance of the <code>RecognizedTarget</code> class containing information about the current target. Besides general information about the target like the name of the target and distance to the target, this object also contains matrices which define the location of the target in the current frame, we pass the object to our renderer instance so it can be used to render something on or around the target. If the &#39;CloudTracker&#39; isn&#39;t able to track the current target any longer it will call the <code>onTargetLost</code> method. In this case we will remove the last <code>RecognizedTarget</code> object from our renderer since it won&#39;t be updated anymore until the <code>CloudTracker</code> recognizes a target again.</p>
<p>The last method <code>onRecognitionFailed</code> will be called if the last recognition attempt was unsuccessful, in this case we will display an error message to the user so that she/he tries again.</p>
<pre><code class="lang-java">    @Override
    public void onTargetRecognized(final CloudTracker cloudTracker_, final String targetName_) {

    }

    @Override
    public void onTracking(final CloudTracker cloudTracker_, final RecognizedTarget recognizedTarget_) {
        _glRenderer.setCurrentlyRecognizedTarget(recognizedTarget_);
    }

    @Override
    public void onTargetLost(final CloudTracker cloudTracker_, final String targetName_) {
        _glRenderer.setCurrentlyRecognizedTarget(null);
    }

    @Override
    public void onRecognitionSuccessful(final CloudTracker cloudTracker_, final JSONObject jsonObject_) {
        if (jsonObject_.toString().length() &gt; 2) {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                        EditText targetInformationTextField = (EditText) findViewById(R.id.on_click_cloud_tracking_target_information);
                        targetInformationTextField.setText(jsonObject_.toString(), TextView.BufferType.NORMAL);
                        targetInformationTextField.setVisibility(View.VISIBLE);
                    }
            });
        }
    }

    @Override
    public void onRecognitionFailed(final CloudTracker cloudTracker_, final int errorCode_, final String errorMessage_) {
        Toast toast = Toast.makeText(getApplicationContext(), &quot;Recognition failed!&quot;, Toast.LENGTH_SHORT);
        toast.show();
    }
</code></pre>
<p>To be able to actually start the recognition we define a button and set an anonymous <code>OnClickListener</code> which calls the <code>CloudTracker</code> recognize method.</p>
<pre><code class="lang-java">@Override
public void onRenderExtensionCreated(final RenderExtension renderExtension_) {
    ...
    Button recognizeButton = (Button) findViewById(R.id.on_click_cloud_tracking_recognize_button);
    recognizeButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(final View view_) {
            _cloudTracker.recognize();
        }
    });

}
</code></pre>
<p><a id="ContinuousCloudRecognition"></a></p>
<h3 id="continuous-cloud-recognition">Continuous Cloud Recognition</h3>
<p>On-Click recognition is useful in some particular cases, but more often than not you probably want to use continuous recognition. For continuous cloud recognition we set an interval in which the <code>CloudTracker</code> automatically calls the recognize function.</p>
<p>Since we want to make sure the <code>CloudTracker</code> finished loading and is ready to be used before we start recognitions, we we&#39;ll use the <code>onTrackerFinishedLoading</code> callback to start the continuous recognition. To do that we call <code>startContinuousRecognition</code> on the <code>CloudTracker</code> instance passing an interval in milliseconds. Since mobile internet can be quite bad, we recommend an interval between 1500 and 2000ms.</p>
<pre><code class="lang-java">@Override
public void onTrackerFinishedLoading(final CloudTracker cloudTracker_) {
    cloudTracker_.startContinuousRecognition(1500);
}
</code></pre>
<p>As already mentioned before internet quality isn&#39;t always the best on mobile devices. If the Wikitude SDK notices that the cloud recogntion interval was set to low, the <code>onRecognitionInterruption</code> callback method will be called. The SDK will pass an adjusted interval which should be more appropriate for the current connection speed. In our example we&#39;ll reset the <code>CloudTracker</code> interval by calling <code>startContinuousRecognition</code> passing the suggested interval.</p>
<pre><code class="lang-java">@Override
public void onRecognitionInterruption(final CloudTracker cloudTracker_, final double suggestedInterval_) {
    cloudTracker_.startContinuousRecognition(suggestedInterval_);
}
</code></pre>

<h2 id="rendering">Rendering</h2>
<p>This example shows and explain how rendering works in combination with the Wikitude SDK Native API. There are two methods of rendering available in the Wikitude Native SDK. We call them internal and external rendering. Internal means the OpenGL view is setup by the Wikitude SDK and the SDK user can define custom rendering, that is executed by the Wikitude SDK. On the other hand external rendering means the SDK user sets up the OpenGL view and integrates the Wikitude SDK into this rendering setup. </p>
<p><a id="externalrendering"></a></p>
<h3 id="external-rendering">External Rendering</h3>
<p>To activate external rendering you need to pass an object implementing the <code>ExternalRendering</code> interface to the constructor of the <code>WikitudeSDK</code> class. In the following example this object will be an instance of the <code>ExternalRenderingActivity</code> class which you can find in our sample application under the package <code>com.wikitude.samples.rendering.external</code>.</p>
<pre><code class="lang-java">public class ExternalRenderingActivity extends Activity implements ClientTrackerEventListener, ExternalRendering {

    private WikitudeSDK _wikitudeSDK;
    ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        _wikitudeSDK = new WikitudeSDK(this);
</code></pre>
<p>In the method <code>onRenderExtensionCreated</code> which is defined by the <code>ExternalRendering</code> interface we receive a <code>RenderExtension</code> instance as a parameter. We pass that parameter to our OpenGL renderer which extends <code>GLSurfaceView.Renderer</code>. We also create a <code>Driver</code> which calls the Renderer 30 times per second to draw the current frame. </p>
<pre><code class="lang-java">    @Override
    public void onRenderExtensionCreated(final RenderExtension renderExtension_) {
        _glRenderer = new GLRenderer(renderExtension_);
        _view = new CustomSurfaceView(getApplicationContext(), _glRenderer);
        _driver = new Driver(_view, 30);
        setContentView(_view);
    }
</code></pre>
<p>The following code shows a very basic implementation of a GLSurfaceView.Renderer. Please note that the first thing to do in every method is to call the WikitudeSDK RenderExtension, otherwise the <code>WikitudeSDK</code> won&#39;t be able to render the camera frame or perform any image recognition.</p>
<pre><code class="lang-java">public class GLRenderer implements GLSurfaceView.Renderer, RenderExtension {

    private RenderExtension _wikitudeRenderExtension = null;
    private RecognizedTarget _currentlyRecognizedTarget = null;
    private StrokedRectangle _strokedRectangle;

    public GLRenderer(RenderExtension wikitudeRenderExtension_) {
        _wikitudeRenderExtension = wikitudeRenderExtension_;
    }

    @Override
    public void onDrawFrame(final GL10 unused) {
        if (_wikitudeRenderExtension != null) {
            _wikitudeRenderExtension.onDrawFrame(unused);
        }
        if (_currentlyRecognizedTarget != null) {
            _strokedRectangle.onDrawFrame(_currentlyRecognizedTarget);
        }
    }

    @Override
    public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
        if (_wikitudeRenderExtension != null) {
            _wikitudeRenderExtension.onSurfaceCreated(unused, config);
        }
        _strokedRectangle = new StrokedRectangle();
    }

    @Override
    public void onSurfaceChanged(final GL10 unused, final int width, final int height) {
        if (_wikitudeRenderExtension != null) {
            _wikitudeRenderExtension.onSurfaceChanged(unused, width, height);
        }
    }

    public void onResume() {
        if (_wikitudeRenderExtension != null) {
            _wikitudeRenderExtension.onResume();
        }
    }

    public void onPause() {
        if (_wikitudeRenderExtension != null) {
            _wikitudeRenderExtension.onPause();
        }
    }

    public void setCurrentlyRecognizedTarget(final RecognizedTarget currentlyRecognizedTarget_) {
        _currentlyRecognizedTarget = currentlyRecognizedTarget_;
    }

}
</code></pre>
<p><a id="internalrendering"></a></p>
<h3 id="internal-rendering">Internal Rendering</h3>
<p>To activate internal rendering you need to pass an object implementing the <code>InternalRendering</code> interface to the constructor of the <code>WikitudeSDK</code> class. In the following example this object will be an instance of the <code>InternalRenderingActivity</code> which you can find in our sample application under the package <code>com.wikitude.samples.rendering.internal</code>.</p>
<pre><code class="lang-java">public class InternalRenderingActivity extends Activity implements InternalRendering, ClientTrackerEventListener {
    ...
    private WikitudeSDK _wikitudeSDK;
    ...
    @Override
    protected void onCreate(final Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        _wikitudeSDK = new WikitudeSDK(this);
           ...
</code></pre>
<p>In the method <code>provideRenderExtension</code> which is defined by the <code>InternalRendering</code> interface we create an instance of our <code>CustomRenderExtension</code> and return it.</p>
<pre><code class="lang-java">    @Override
    public RenderExtension provideRenderExtension() {
        _renderExtension = new CustomRenderExtension();
        return _renderExtension;
    }
</code></pre>
<p>The CustomRenderExtension was defined like in the following code snippet. All defined methods will be called in the appropriate methods of the <code>WikitudeSDK</code> renderer which extends the standard Android <code>GLSurfaceView.Renderer</code>.</p>
<pre><code class="lang-java">public class CustomRenderExtension implements GLSurfaceView.Renderer, RenderExtension {

    private RecognizedTarget _currentlyRecognizedTarget = null;
    private StrokedRectangle _strokedRectangle;

    @Override
    public void onDrawFrame(final GL10 unused) {
        if (_currentlyRecognizedTarget != null) {
            _strokedRectangle.onDrawFrame(_currentlyRecognizedTarget);
        }
    }

    @Override
    public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
        _strokedRectangle = new StrokedRectangle();
    }

    @Override
    public void onSurfaceChanged(final GL10 unused, final int width, final int height) {
    }

    public void onResume() {
    }

    public void onPause() {
    }

    public void setCurrentlyRecognizedTarget(final RecognizedTarget currentlyRecognizedTarget_) {
        _currentlyRecognizedTarget = currentlyRecognizedTarget_;
    }

}
</code></pre>

<h2 id="plugins-api">Plugins API</h2>
<p>This guide consists of multiple sections, first we discuss Wikitude SDK Plugins in general, than we talk about platform specifics and how to register a plugin with the Wikitude SDK and then we go through each of the sample plugins included with the Wikitude Example Applications.</p>
<ol>
<li><a href="#about">About Wikitude SDK Plugins</a></li>
<li><a href="#platformspecifics">Platform Specifics</a></li>
<li><a href="#registerplugin">Registering Plugins</a></li>
<li><a href="#barcode">QR &amp; Barcode Plugin</a></li>
<li><a href="#facedetection">Face Detection Plugin</a></li>
</ol>
<p><a id="about"></a></p>
<h3 id="about-wikitude-sdk-plugins">About Wikitude SDK Plugins</h3>
<p>Technically a plugin is a class, either written in C++ or Java, that is derived from the Wikitude Plugin base class. Beside lifecycle handling and options to enable and disable the plugin, the Plugin class has four main methods that you can override <code>cameraFrameAvailable</code> which is called each time the camera has a new frame, <code>update</code> which is called after each image recogntion cycle as well as &#39;startRender&#39; and &#39;endRender&#39; which are called before and after the Wikitude SDK does its rendering.</p>
<p>The most important thing to remember when working with plugins is that they need to have a unique identifier! If the attempt is made to register a plugin with an identifier that is already known to the Wikitude SDK, the register method call will return false.</p>
<h3 id="plugin-base-class">Plugin Base Class</h3>
<pre><code>class Plugin {
   public:
      Plugin(std::string identifier_);
      ~Plugin();
      string getIdentifier() const; // returns a unique plugin identifier
      bool processesColorCameraFrames(); // returns true if the plugins wants to process color frames instead of bw

      void setEnabled(bool enabled_);
      bool isEnabled();

      string callJavaScript(string javaScriptSnippet); // evaluates the given JavaScript snippet in the currently loaded ARchitect World context.

   protected:
      void initialize(); // called when the plugin is initially added to the Wikitude SDK
      void pause(); // called when the Wikitude SDK is paused e.g. the application state changes from active to background
      void resume(uint pausedTime_); // called when the Wikitude SDK resumes e.g. from background to active state. pausedTime represents the time in milliseconds that the plugin was not updated.
      void destroy(); // called when the plugin is removed from the Wikitude SDK

      void cameraFrameAvailable(const Frame&amp;; cameraFrame_); // called each time the camera has a new frame
      void update(const vector&lt;RecognizedTarget&gt; recognizedTargets_); // called each time the Wikitude SDK renders a new frame

      void startRender(); // called before any Wikitude SDK internal rendering is done
      void endRender(); // called right after any Wikitude SDK internal rendering is done

   protected:
      string      _identifier;
      bool        _enabled;
};
</code></pre><p>With those methods in place your plugin will be able to read the full camera image for your own purpose, where the YUV image is also processed in wikitude’s computer vision engine.</p>
<h3 id="information-about-recognized-targets">Information about Recognized Targets</h3>
<p>In case you have the wikitude SDK running with ongoing image recognition, the plugin API will populate the <code>RecognizedTarget</code> in the <code>update</code> method once an image has been recognized. The plugin can then work with class RecognizedTarget, which wraps the details of the target image in the camera view. With that you can read out the pose of the target image and use it for your purposes. Additionally the call contains the calculated distance to the recognized target</p>
<pre><code>class RecognizedTarget {
   public:
      const string&amp;    getIdentifier() const; // the identifier of the target. The identifier is defined when the target is added to a target collection
      const Mat4&amp;      getModelViewMatrix() const; // the model view matrix that defines the transformation of the target in the camera frame (translation, rotation, scale)
      const Mat4&amp;      getProjectionMatrix() const;
      const float      getDistanceToCamera() const; // represents the distance from the target to the camera in millimeter
};
</code></pre><p>Passing values from within the plugin to the JavaScript part of your augmented reality experience is done via the <code>addToJavaScriptQueue()</code> method of the Plugin class. Using this function will execute any JavaScript code in the context of your augmented reality experience.</p>
<p><a id="platformspecifics"></a></p>
<h3 id="platform-specifics">Platform Specifics</h3>
<p>To be able to use a C++ Wikitude plugin on Android, it is necessary to create a binary from the C++ code for each supported CPU architecture. To make this process as easy as possible we prepared an Android NDK make file and and some template code which passes your plugin to the Wikitude SDK. In the following section we discuss how you need to adapt these templates so they&#39;ll work for your plugin. </p>
<p>Please note that if you would like to use multiple C++ plugins in your app, you will need to package all plugins in one shared library. This is necessary because we use JNI to register C++ plugins with the Wikitude SDK and the symbol to do that has to be unique.</p>
<h3 id="android-c-wikitude-plugin-library-build">Android C++ Wikitude Plugin Library Build</h3>
<p>All files needed are located under the folder PluginBuilder in the Wikitude SDK Android package.
If you didn&#39;t setup the Android NDK yet, please follow the <a href="https://developer.android.com/intl/ja/ndk/guides/setup.html">official guide</a>.</p>
<p>Let&#39;s take a look at the Android.mk file, located under <code>SDKPackageRoot/PluginBuilder/jni</code>. The first thing we do is declare a variable containing the path to the source files relative to the make files location and set <code>LOCAL_PATH</code> to this location. We define where all include files are located and which files need to be compiled. Since our Example Plugin uses Android log we link android native log.</p>
<pre><code>LOCAL_PATH := $(call my-dir)/..
SRC_DIR := $(LOCAL_PATH)/src

include $(CLEAR_VARS)

LOCAL_PATH := $(SRC_DIR)
include $(CLEAR_VARS)

LOCAL_MODULE := samplePlugin

LOCAL_C_INCLUDES := $(SRC_DIR)
LOCAL_SRC_FILES := __YOUR_PLUGIN__.cpp JniRegistration.cpp Plugin.cpp

LOCAL_LDLIBS += -llog

include $(BUILD_SHARED_LIBRARY)
</code></pre><p>The PluginLoader/src folder contains various src files which are needed so your plugin will compile and link correctly. Please don&#39;t modify any of them except the <code>__YOUR_PLUGIN__.h</code> and <code>__YOUR_PLUGIN__.cpp</code>. One other file that needs some slight modifications is <code>JniRegistration.cpp</code> shown below. Adapt the include directive and the constructor call to your plugin name and if you would like to use multiple C++ plugins, feel free to add more plugins to the <code>cPluginsArray</code> array but adjust the <code>numberOfPlugins</code> count accordingly.</p>
<p>If you packaged multiple plugins in one shared library but would like to instantiate only a subset of those plugins you can pass an identifier to this method when loading the library from Java. You can then decide which plugins to create depending on the value of <code>jPluginName</code>.</p>
<pre><code>#include &lt;jni.h&gt;

#include &quot;Plugin.h&quot;
#include &quot;__YOUR_PLUGIN__.h&quot;

extern &quot;C&quot; JNIEXPORT jlongArray JNICALL Java_com_wikitude_architect_PluginManager_createNativePlugins(JNIEnv *env, jobject thisObj, jstring jPluginName) {

    int numberOfPlugins = 1;

    jlong cPluginsArray[numberOfPlugins];
    cPluginsArray[0] = (jlong) new __YOUR_PLUGIN__(&quot;com.example.plugin&quot;);

    jlongArray jPluginsArray = env-&gt;NewLongArray(numberOfPlugins);
    if (jPluginsArray != nullptr) {
        env-&gt;SetLongArrayRegion(jPluginsArray, 0, numberOfPlugins, cPluginsArray);
    }

    return jPluginsArray;
}
</code></pre><p>To build the plugin binary files, navigate to the jni folder and call ndk-build. A libs folder will be created containing libraries for arm7, arm64 and intel. Copy the contents of the libs folder to <code>YourProjectRoot/app/src/main/jniLibs</code>. </p>
<p><a id="registerplugin"></a></p>
<h3 id="registering-plugins">Registering Plugins</h3>
<h3 id="register-c-plugin">Register C++ Plugin</h3>
<p>To register a C++ plugin with the Wikitude Native SDK, get the <code>PluginManager</code> from the <code>WikitudeSDK</code> instance and call <code>registerNativePlugin</code> passing the name of your library. Do not add <code>lib</code> in front of the name or add the <code>.so</code> extension. If you register your Plugin in the <code>onCreate</code> method of your activity, please also make sure to call the <code>onCreate</code> method of the <code>WikitudeSDK</code> first. The following snippet comes from the <code>BarcodePluginActivity</code> of the Wikitude Native SDK Example application.</p>
<pre><code class="lang-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    ...
    _wikitudeSDK.onCreate(getApplicationContext(), startupConfiguration);
    ...
    _wikitudeSDK.getPluginManager().registerNativePlugins(&quot;barcodePlugin&quot;);
}
</code></pre>
<h3 id="register-java-plugin">Register Java Plugin</h3>
<p>To register a Java plugin with the Wikitude Native SDK, get the <code>PluginManager</code> from the <code>WikitudeSDK</code> instance and call <code>registerPlugin</code> passing an instance of your <code>Plugin</code>.</p>
<pre><code class="lang-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    ...
    _wikitudeSDK.onCreate(getApplicationContext(), startupConfiguration);
    ...
    _wikitudeSDK.getPluginManager().registerPlugin(new MyPlugin());
}
</code></pre>
<p><a id="barcode"></a></p>
<h3 id="barcode-and-qr-code-reader">Barcode and QR code reader</h3>
<p>This samples shows a full implementation of the popular barcode library ZBar into the Wikitude SDK. As ZBar is licensed under LGPL2.1 this sample can also be used for other projects.</p>
<p>ZBar is an open source software suite for reading bar codes from various sources, such as video streams, image files and raw intensity sensors. It supports many popular symbologies (types of bar codes) including EAN-13/UPC-A, UPC-E, EAN-8, Code 128, Code 39, Interleaved 2 of 5 and QR Code.</p>
<p>In the <code>BarcodePluginActivity.onCreate</code> method we register the bar code C++ plugin by getting the <code>PluginManager</code> from the Wikitude SDK and calling <code>registerNativePlugins</code> passing the name of the native library containing our C++ plugin. Right after that we call initNative(), which we declared as a native method and implement in the C++ plugin, to initialize the JavaVM pointer hold by the native plugin. We also implement the method <code>onBarcodeDetected</code> to display the contents of the scanned bar code. We&#39;ll later call this method from the bar code plugin. </p>
<pre><code class="lang-java">public class BarcodePluginActivity extends Activity implements ClientTrackerEventListener, ExternalRendering {

    private static String _codeContent;
    ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        _wikitudeSDK.getPluginManager().registerNativePlugins(&quot;barcodePlugin&quot;);
        initNative();
    }

    ...

    public void onBarcodeDetected(final String codeContent_) {
        _codeContent = codeContent_;
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                EditText targetInformationTextField = (EditText) findViewById(R.id.barcode_plugin_info_field);
                targetInformationTextField.setText(codeContent_, TextView.BufferType.NORMAL);
                targetInformationTextField.setVisibility(View.VISIBLE);
            }
        });
    }

    private native void initNative();
}
</code></pre>
<p>Now let&#39;s move to the plugins C++ code. First we&#39;ll have a look at the <code>BarcodePlugin.h</code> file. To create the bar code plugin we derive our <code>BarcodePlugin</code> class from <code>wikitude::sdk::Plugin</code> and override <code>initialize</code>, <code>destroy</code>, <code>cameraFrameAvailable</code> and <code>update</code>. We also declare the following member variables: <code>_worldNeedsUpdate</code>, <code>_image</code>, <code>_imageScanner</code> and <code>_methodId</code>. The <code>_worldNeedsUpdate</code> variable will later be used as an indicator if we need to update the <code>View</code>, <code>_image</code> and <code>_imageScanner</code> are classes from <code>zBar</code> which we&#39;ll use to scan for bar codes and <code>_methodId</code> will hold the method id of the <code>onBarcodeDetected</code> Java method. </p>
<pre><code class="lang-c++">extern JavaVM* pluginJavaVM;

class BarcodePlugin : public wikitude::sdk::Plugin {
public:
    BarcodePlugin(int cameraFrameWidth, int cameraFrameHeight);
    virtual ~BarcodePlugin();

    virtual void initialize();
    virtual void destroy();

    virtual void cameraFrameAvailable(const wikitude::sdk::Frame&amp; cameraFrame_);
    virtual void update(const std::list&lt;wikitude::sdk::RecognizedTarget&gt;&amp; recognizedTargets_);


protected:
    int                             _worldNeedsUpdate;

    zbar::Image                     _image;
    zbar::ImageScanner              _imageScanner;

private:
    jmethodID                       _methodId;
};
</code></pre>
<p>We declare two variables in the global namespace one which will hold a pointer to the JavaVM and one which will hold a reference to our activity. To initialize those two variables we declared the <code>initNative</code> native method in the <code>BarcodeActivity</code> and implement it like in the following code snippet. All we do is get the pointer to the <code>JavaVM</code> from the <code>JNIEnv</code> and create a new global reference to the calling activity instance.</p>
<pre><code class="lang-c++">JavaVM* pluginJavaVM;
jobject activityObj;

extern &quot;C&quot; JNIEXPORT void JNICALL
Java_com_wikitude_samples_plugins_BarcodePluginActivity_initNative(JNIEnv* env, jobject obj)
{
    env-&gt;GetJavaVM(&amp;pluginJavaVM);
    activityObj = env-&gt;NewGlobalRef(obj);
}
</code></pre>
<p>In the constructor we set <code>_worldNeedsUpdate</code> to zero indicating that there is no update necessary and initialize the <code>zBar::Image</code> member variable passing its constructor the width and height of the camera frame, the image format of <code>Y800</code>, set its data pointer to null and the data length to zero. We use the JavaVM to create an instance of <code>JavaVMResource</code> which is a helper class to manage the JavaVM, we provided in the file <code>jniHelper.cpp</code>. Next we get the Java environment from the <code>JavaVMResource</code> and initialize the <code>_methodId</code> member. In the destructor we delete the global reference to the activity object.</p>
<pre><code class="lang-c++">BarcodePlugin::BarcodePlugin(int cameraFrameWidth, int cameraFrameHeight) :
Plugin(&quot;com.wikitude.ios.barcodePluign&quot;),
_worldNeedsUpdate(0),
_image(cameraFrameWidth, cameraFrameHeight, &quot;Y800&quot;, nullptr, 0)
{
    JavaVMResource vm(pluginJavaVM);
    jclass clazz = vm.env-&gt;FindClass(&quot;com/wikitude/samples/plugins/BarcodePluginActivity&quot;);
    _methodId = vm.env-&gt;GetMethodID(clazz, &quot;onBarcodeDetected&quot;, &quot;(Ljava/lang/String;)V&quot;);
}

BarcodePlugin::~BarcodePlugin()
{
    JavaVMResource vm(pluginJavaVM);
    vm.env-&gt;DeleteGlobalRef(activityObj);
}
</code></pre>
<p>In the <code>initialize</code> method we configure the <code>zbar::ImageScanner</code> by calling <code>setConfig</code>, enabling all supported bar codes. If you are only interested in one or some particular types of codes, first disabling all bar code types and manually enabling each particular type would be the better idea. That way performance could be greatly improved.</p>
<pre><code class="lang-c++">void BarcodePlugin::initialize() {    
    _imageScanner.set_config(zbar::ZBAR_NONE, zbar::ZBAR_CFG_ENABLE, 1);
}
</code></pre>
<p>We react to the <code>destroy</code> event by setting the current data pointer of the <code>zbar::Image</code> member to null and length to zero.</p>
<pre><code class="lang-c++">void BarcodePlugin::destroy() {
    _image.set_data(nullptr, 0);
}
</code></pre>
<p>The last but most interesting methods are <code>cameraFrameAvailable</code> and <code>update</code>. In the <code>cameraFrameAvailable</code> method we set the data of our previously initialized <code>zbar::Image</code> member variable to the frame data we just received and the length of the data to frame width * frame height by calling <code>set_data</code>. We then start the scanning process by calling the <code>scan</code> method of our <code>zBar::ImageScanner</code> passing the <code>zBar::Image</code> member instance. The <code>zBar::ImageScanner::scan</code> method returns the number of detected bar codes in the image frame, we save this number in a local variable <code>n</code>. If <code>n</code> is not equal to the result of the last frame, which we saved to <code>_worldNeedsUpdate</code> member variable, we know there was a new bar code detected (meaning there was no bar code in the last frame) or that there was a bar code in the last frame and now there isn&#39;t. When that&#39;s the case, we do another check if there really was a bar code detected this frame and if there was we call the <code>onBarcodeDetected</code> Java method passing the code content.</p>
<pre><code class="lang-c++">void BarcodePlugin::cameraFrameAvailable(const wikitude::sdk::Frame&amp; cameraFrame_) {
    int frameWidth = cameraFrame_.getSize().width;
    int frameHeight = cameraFrame_.getSize().height;

    _image.set_data(cameraFrame_.getLuminanceData(), frameWidth * frameHeight);

    int n = _imageScanner.scan(_image);

    if ( n != _worldNeedsUpdate ) {
        if ( n ) {

            zbar::Image::SymbolIterator symbol = _image.symbol_begin();
            JavaVMResource vm(pluginJavaVM);
            jstring codeContent = vm.env-&gt;NewStringUTF(symbol-&gt;get_data().c_str());
            vm.env-&gt;CallVoidMethod(activityObj, _methodId, codeContent);

        }
    }

    _worldNeedsUpdate = n;
}
</code></pre>
<p><a id="facedetection"></a></p>
<h3 id="face-detection">Face Detection</h3>
<p>This samples shows how to add face detection to your Wikitude augmented reality experience using OpenCV.</p>
<p>The Face Detection Plugin Example consists of the C++ classes <code>FaceDetectionPlugin</code>, <code>FaceDetectionPluginConnector</code> and the Java class <code>FaceDetectionPluginActivity</code>. We will use OpenCV to detect faces in the current camera frame and OpenGL calls in Java to render a frame around detected faces. </p>
<p>The <code>FaceDetectionPluginConnector</code> acts as our interface between native code and Java and contains some JNI code, since JNI is not the focus of this example we won&#39;t go into detail about the implementation. If you would like to have a look at the complete code feel free to browse the source code in the Wikitude SDK release package.</p>
<p>We implement to Java native methods <code>initNative</code> and <code>setFlipFlag</code>. First will be used to initialize the plugin with the path to an OpenCV database, second will be used to notify the Plugin about orientation changes of the device. The other methods <code>faceDetected</code>, <code>faceLost</code>, <code>projectionMatrixChanged</code> and <code>renderDetectedFaceAugmentation</code> will be called by the Plugin to update the Java Android Activity, which controls the rendering. </p>
<pre><code class="lang-c++">extern &quot;C&quot; JNIEXPORT void JNICALL
Java_com_wikitude_samples_plugins_FaceDetectionPluginActivity_initNative(JNIEnv* env, jobject obj, jstring databasePath_)
{
    ...
}

extern &quot;C&quot; JNIEXPORT void JNICALL
Java_com_wikitude_samples_plugins_FaceDetectionPluginActivity_setFlipFlag(JNIEnv* env, jobject obj, jint flag)
{
    ...
}

... ctor / dtor ...

void FaceDetectionPluginConnector::faceDetected(const float *modelViewMatrix)
{
...
}

void FaceDetectionPluginConnector::faceLost()
{
...
}

void FaceDetectionPluginConnector::projectionMatrixChanged(const float *projectionMatrix)
{
...
}

void FaceDetectionPluginConnector::renderDetectedFaceAugmentation() {
...
}
</code></pre>
<p>Next we have a look at the <code>FaceDetectionPlugin</code> class. Again we we will leave out implementation details and focus on how we use the plugin itself. In the <code>cameraFrameAvailable</code> method we use OpenCV to detect faces in the current camera frame which the Wikitude SDK passes to the plugin. We call the observer which is an instance of the <code>FaceDetectionPluginConnector</code> to notify the Java activity about the result. The plugin base class defines <code>startRender</code> and <code>endRender</code>, depending on, if you would like to render on top of or below of all rendering the Wikitude SDK does, you choose one of them, or both to override. To render below all Wikitude rendering we choose <code>startRender</code> and again call the <code>FaceDetectionPluginConnector</code> instance which in turn calls the Android activity. Since we do not react on the result of the Wikitude SDK image recognition we leave <code>update</code> blank. </p>
<pre><code class="lang-c++">
... ctor/dtor ...

void FaceDetectionPlugin::cameraFrameAvailable(const wikitude::sdk::Frame&amp; cameraFrame_) {

    ... Control Open CV ...

    if ( _result.size() ) {
        convertFaceRectToModelViewMatrix(croppedImg, _result.at(0));
        _observer-&gt;faceDetected(_modelViewMatrix);
    } else {
        _observer-&gt;faceLost();
    }
}

void FaceDetectionPlugin::startRender() {
    _observer-&gt;renderDetectedFaceAugmentation();
}

void FaceDetectionPlugin::update(const std::list&lt;wikitude::sdk::RecognizedTarget&gt; &amp;recognizedTargets_) {
}

... other internally used methods ...
</code></pre>
<p>In the <code>FaceDetectionPluginActivity</code> we override <code>onCreate</code> and initialize the Plugin by calling the initNative native method, passing the path to the database file. We also override <code>onConfigurationChanged</code> to get notify about device orientation changes and again notify the Plugin about orientation changes by calling the <code>setFlipFlag</code> native method. To render a frame around detected faces we created an instance of <code>GLRendererFaceDetectionPlugin</code> class which takes care of rendering a rectangle around faces and all targets of the also active <code>ClientTracker</code>. When the plugin detects, looses or recalculated the projection matrix it will call the appropriate Java methods which we use to update the <code>Renderer</code> instance. If the Plugin decides it is time to render a frame around a detected face it will call <code>renderDetectedFaceAugmentation</code>. Since the plugin will only call this method in the <code>startRender</code> method, we know the current thread is the OpenGL thread and are able to dispatch OpenGL calls.</p>
<pre><code class="lang-java">
... imports ...

public class FaceDetectionPluginActivity extends Activity implements ClientTrackerEventListener, ExternalRendering {

    private WikitudeSDK _wikitudeSDK;
    private GLRendererFaceDetectionPlugin _glRenderer;
    private File _cascadeFile;
    private RecognizedTarget _faceTarget = new RecognizedTarget();

    ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {

        ... init native sdk ...

        ... copy database file ...

        initNative(_cascadeFile.getAbsolutePath());

        ...

        setInterfaceOrientationInPlugin();
    }

    ... other lifecycle events ...

    private void setInterfaceOrientationInPlugin() {
        ...
        setFlipFlag(x);
        ...
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        setInterfaceOrientationInPlugin();
    }

    public void onFaceDetected(float[] modelViewMatrix) {
        _faceTarget.viewMatrix = modelViewMatrix;
        _glRenderer.setCurrentlyRecognizedFace(_faceTarget);
    }

    public void onFaceLost() {
        _glRenderer.setCurrentlyRecognizedFace(null);
    }

    public void onProjectionMatrixChanged(float[] projectionMatrix) {
        _faceTarget.projectionMatrix = projectionMatrix;
        _glRenderer.setCurrentlyRecognizedFace(_faceTarget);
    }

    ... other Wikitude callbacks ...

    private native void initNative(String casecadeFilePath);
    private native void setFlipFlag(int flag);
}
</code></pre>
<p>If you are interested in the implementation details of the <code>FaceDetectionPluginActivity</code> or the <code>StrokedRectangle</code> class, you can find both classes in our Wikitude SDK Example Application. </p>

<h2 id="camera-controls">Camera Controls</h2>
<p>The <code>CameraManager</code> allows you to switch between front and back camera, continuous focus and one time focus as well as control the zoom. We created a <code>activity_camera_control.xml</code> layout file, were we define some simple ui components for all exposed settings, please browse the sample app code if you would like to have a look at this file.</p>
<p>With the layout file in place we are ready to connect the UI components and the <code>CameraManager</code>. </p>
<p>The first component we connect is the flash light on/off switch, were we set a anonymous <code>OnCheckedChangeListener</code> in which we retrieve the <code>CameraManager</code> from the WikitudeSDK and enable or disable the flash light by calling <code>enableCameraFlash</code> or <code>disableCameraFlash</code>. </p>
<p>For the zoom <code>SeekBar</code> we first set the maximum value of the <code>SeekBar</code> to the maximum zoom value returned by the <code>CameraManager</code>, to create a wider range of values we multiply the returned value by 100. Then again we set a anonymous Listener to react on the user input. Since we widened the value range, we need to divide the current <code>Seekbar</code> value by 100 before we pass it back to the <code>CameraManager</code> by calling <code>setZoomLevel</code>.</p>
<pre><code class="lang-java">    @Override
    public void onRenderExtensionCreated(final RenderExtension renderExtension_) {

        ...

        Switch flashToggleButton = (Switch) findViewById(R.id.flashlight);
        flashToggleButton.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(final CompoundButton buttonView, final boolean isChecked) {
                if (isChecked) {
                    _wikitudeSDK.getCameraManager().enableCameraFlashLight();
                } else {
                    _wikitudeSDK.getCameraManager().disableCameraFlashLight();
                }

            }
        });

        SeekBar zoomSeekBar = (SeekBar) findViewById(R.id.zoomSeekBar);
        zoomSeekBar.setMax(((int) _wikitudeSDK.getCameraManager().getMaxZoomLevel()) * 100);
        zoomSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(final SeekBar seekBar, final int progress, final boolean fromUser) {
                if (progress &gt; 0) {
                    _wikitudeSDK.getCameraManager().setZoomLevel((float) progress / 100.0f);
                }
            }

            @Override
            public void onStartTrackingTouch(final SeekBar seekBar) {

            }

            @Override
            public void onStopTrackingTouch(final SeekBar seekBar) {

            }
        });
</code></pre>
<p>Since we use two <code>Spinners</code> to control the camera position and focus mode, we don&#39;t go with anonymous listeners, but let the activity implement <code>onItemSelectedListener</code> and handle both spinners in the same method. For both focus mode and camera position <code>CameraManager</code> exposes setters to pick a value. We use the appropriate <code>enums</code> provided by the <code>CameraSettings</code> class to choose from the available settings.</p>
<pre><code class="lang-java">    @Override
    public void onRenderExtensionCreated(final RenderExtension renderExtension_) {

        ...

        Spinner cameraPositionSpinner = (Spinner) findViewById(R.id.cameraPosition);
        ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.createFromResource(this, R.array.camera_positions, android.R.layout.simple_spinner_item);
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        cameraPositionSpinner.setAdapter(adapter);
        cameraPositionSpinner.setOnItemSelectedListener(this);

        Spinner focusModeSpinner = (Spinner) findViewById(R.id.focusMode);
        adapter = ArrayAdapter.createFromResource(this, R.array.focus_mode, android.R.layout.simple_spinner_item);
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        focusModeSpinner.setAdapter(adapter);
        focusModeSpinner.setOnItemSelectedListener(this);
    }

    @Override
    public void onItemSelected(final AdapterView&lt;?&gt; adapterView_, final View view_, final int position, final long id) {
        switch (adapterView_.getId()) {
            case R.id.focusMode:
                if (position == 0) {
                    _wikitudeSDK.getCameraManager().setFocusMode(CameraSettings.CameraFocusMode.CONTINUOUS);
                } else {
                    _wikitudeSDK.getCameraManager().setFocusMode(CameraSettings.CameraFocusMode.ONCE);
                }
                break;
            case R.id.cameraPosition:
                if (position == 0) {
                    _wikitudeSDK.getCameraManager().setCameraPosition(CameraSettings.CameraPosition.BACK);
                } else {
                    _wikitudeSDK.getCameraManager().setCameraPosition(CameraSettings.CameraPosition.FRONT);
                }
                break;
        }
    }
</code></pre>

<h1 id="wikitude-2d-tracking">Wikitude 2D Tracking</h1>
<p>In this section of the documentation we are covering tools shipped with the Wikitude SDK, which help you in your development. </p>
<ol>
<li><a href="targetmanagement.html#target-management">Target Manager</a></li>
<li><a href="targetguide.html">Best practice for target images</a></li>
</ol>

<h2 id="target-management">Target Management</h2>
<p>This guide gives you an overview of how to create a target collection that you can use to detect and track images within your augmented reality experience.</p>
<p>In general the conversion can be done via three different tools:</p>
<ol>
<li>Web Target Manager Tool: A browser based tool to convert your images to a wtc file. You can find the tool under:  <a href="https://targetmanager.wikitude.com" target="_blank">https://targetmanager.wikitude.com</a>. You need your free developer account to log-in. This tool is described in more detail on further below</li>
<li>RESTful API. Make use of all features provided by the web tool via direct server endpoints.</li>
<li>Targets Enterprise Script: A binary shell script available for Mac OS X and Linux converting images to target collections. Pleases <a href="mailto:sales@wikitude.com">contact Wikitude Sales</a> team for technical requirements and pricing.</li>
</ol>
<p>The following images describes the relationship between the above mentioned methods and the Wikitude Cloud Recognition Service, which is not scope of this documentation. </p>
<p><img style="width: 500px" src="images/150212_WT_Infografik_OfflineOnlineRecognition_01.jpg"></p>
<h3 id="web-targetmanager">Web Targetmanager</h3>
<h3 id="add-a-new-project">Add a new project</h3>
<ul>
<li>Open <a href="https://targetmanager.wikitude.com" target="_blank">https://targetmanager.wikitude.com</a> and login with your Wikitude Developer account</li>
<li>Add a new project to your project collection</li>
</ul>
<p><img style="width: 500px" src="images/tmt_CreateProject.png"></p>
<h3 id="add-target-images">Add target images</h3>
<ul>
<li>Enter an existing project </li>
<li>Add new target images to the project either by clicking on <code>Add Targets</code> or drag  &amp; drop them on the empty area. Supported file formats include PNG and JPEG. If you are using PNG images, please make sure that it does not contain any transparent pixels, only solid colored images are supported.</li>
</ul>
<p><img style="width: 500px" src="images/tmt_AddTargets.png">    </p>
<ul>
<li>When uplaoding a target the file name is used as <code>target name</code>. It identifies a target in your experience. If the <code>target name</code> is not completely visible, hover over it to reveal the full name or double click the target to enter edit-mode.</li>
</ul>
<div class="warning">
<strong>Important</strong> <br />
If you add your own target images  you need the target name to set them in  <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>.</div>


<h3 id="star-rating">Star Rating</h3>
<ul>
<li><strong>0 stars:</strong> Not suitable for tracking. This target image cannot be tracked because it lacks textured features with high local contrast. Please consider choosing another target image.</li>
<li><strong>1 star:</strong>  Limited tracking ability. This target image provides basic tracking performance in good lightning conditions. Please consider improving the image</li>
<li><strong>2 stars:</strong> Good tracking ability. This target image will track well in most conditions.</li>
<li><strong>3 stars:</strong> Very good tracking ability. This target image will track very well in most conditions.</li>
</ul>
<p>General advice for reference images</p>
<ul>
<li>Good image characteristics:<ul>
<li>Diversely textured image with high local contrast</li>
</ul>
</li>
<li>Bad image characteristics:<ul>
<li>Large areas with solid color or smooth color transitions</li>
<li>Repetitive patterns</li>
<li>Logos, signs        </li>
</ul>
</li>
</ul>
<h3 id="create-a-wtc-file">Create a WTC file</h3>
<ul>
<li>AR.ClientTracker requires a WTC (Wikitude Target Collection) file which contains all information of the targets that should be recognized. Enter the project you need the file for and click the <em>WTC icon</em> in the toolbar.</li>
</ul>
<p><img style="width: 500px" src="images/tmt_CreateTargetCollection.png"></p>
<ul>
<li>Select the Wikitude SDK version you&#39;re using and click <em>Generate</em> to trigger the creation of the WTC file. You will be notified via e-Mai once the file is available for download.</li>
</ul>
<p><img style="width: 500px" src="images/tmt_TargetCollections.png"></p>
<h3 id="use-project-s-wtc-file-in-your-architect-world">Use project&#39;s WTC file in your ARchitect World</h3>
<p>Look at one of the <a href="clientrecognition.html">client recognition examples</a> or refer to the JavaScript API reference of <a href="../Reference/JavaScript%20API/classes/ClientTracker.html"><code>AR.ClientTracker</code></a> for instructions on how to use the created target collection for augmentations in your ARchitect Worlds.</p>
<h3 id="cloud-recognition">Cloud Recognition</h3>
<p>Any existing project may also be published to the Cloud to make it accessible for <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>. </p>
<p>Click the <em>Cloud icon</em> in the toolbar for more details.</p>
<p><img style="width: 500px" src="images/tmt_CloudIcon.png"></p>
<p>Cloud Recognition is available for free in your testing process but you must purchase a license for productive use. <a href="http://www.wikitude.com/external/doc/documentation/latest/cloudrecognition/gettingstartedcloudrecognition.html#quota-and-limits">Learn more</a></p>
<p><img style="width: 500px" src="images/tmg_CloudPublishing.png"></p>
<p>Once a project is published it is accessible via Wiktiude SDK using &#39;Client Token&#39; and &#39;Target Collection ID&#39; (compare <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>) </p>
<p><img style="width: 500px" src="images/tmt_CloudTracker.png"></p>
<p>Hints</p>
<ul>
<li><p>You may unpublish a project at any time but be aware that this action has immediate effect on your application(s) making use of the credentials.</p>
</li>
<li><p><strong>Metadata</strong> in the &#39;Edit Target&#39; dialog is solely relevant for Cloud Recognition whereat <strong>Physical Height</strong> is only relevant for distanceToTarget feature.</p>
</li>
<li><p>Leave <strong>Physical Height</strong> empty if you do not use the distanceToTarget feature of <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>.</p>
</li>
<li><p>The <strong>Metadata</strong> field is very useful. It allows you to attach JSON data to a target. That way you can define any kind of additional data and react on it dynamically in the SDK to e.g. let a button refer to a details page which is defined in the Metadata JSON.</p>
</li>
</ul>
<p><img style="width: 500px" src="images/tmt_CloudTargetEdit.png"></p>

<h2 id="best-practice-for-target-images">Best practice for target images</h2>
<p>This guide gives you an overview of how to create a target collection that you can use to detect and track images within your ARchitect World.</p>
<h3 id="summary">Summary</h3>
<p><strong>Preferred images have:</strong></p>
<ul>
<li>between 500 to 1000 pixels in each dimension</li>
<li>Rich contrast</li>
<li>Evenly distributed textured areas</li>
<li>Many corner like structures</li>
</ul>
<p><strong>Unsuitable images have:</strong></p>
<ul>
<li>Smaller dimensions than 500 pixels</li>
<li>Larger than 1000 pixels as they do not provide more accurate results</li>
<li>Large amounts of text</li>
<li>Many repetitive patterns</li>
<li>Large single-colored areas </li>
<li>Color contrast only e.g. green to red edge), because all images are processed as grayscale images</li>
</ul>
<h3 id="optimal-image-dimensions">Optimal Image Dimensions</h3>
<ul>
<li>Optimal images are sized between 500 and 1000 pixels in each dimension</li>
<li>Small images do not contain enough graphical information to extract so called feature points. The uniqueness, amount and distribution of features points are the key indicators for good detection and tracking quality</li>
<li>Larger images do not improve the tracking quality
<img src="images/guide_dimension_wrong.png" alt="Target image too small">
<img src="images/guide_dimension_good.png" alt="Optimal size of target image"></li>
</ul>
<h3 id="low-contrast-images">Low contrast images</h3>
<ul>
<li>Images with high local contrast and large amount of rich textured areas is best suited for reliable detection and tracking</li>
<li>Color contrast only (i.e. green to red edge) appears as high contrast to the human eye but is not discriminative to computer vision algorithms as they are operating on grayscale images
<strong><em>Tip</em></strong>: For low contrast images, try to increase the contrast of your target image with an image editing tool like Gimp or PhotoShop to improve detection and tracking quality</li>
</ul>
<p><img src="images/low_contrast_wrong.png" alt="Target image with low contrast">
<img src="images/low_contrast_good.png" alt="Target image with good contrast"></p>
<h3 id="distribution-of-textured-areas">Distribution of textured areas</h3>
<ul>
<li>Images with evenly distributed textured areas are good candidates for reliable detection and tracking</li>
<li>This might be the hardest part to be in control of and often can’t be changed.
<strong><em>Tip</em></strong>: Try to crop the most prominent part of your image and use only this as target image.</li>
</ul>
<p><img src="images/texture_distribution_wrong.png" alt="Target image with not optimal distribution">
<img src="images/texture_distribution_good.png" alt="Even distribution of features"></p>
<h3 id="images-with-whitespace">Images with whitespace</h3>
<ul>
<li>Single-colored areas or smooth color transitions often found in backgrounds do not exhibit graphical information suitable for detection and tracking. 
<strong><em>Tip</em></strong>: Try to crop the most prominent part of your image and use only this as target image.</li>
</ul>
<p><img src="images/whitespace_wrong.png" alt="Too much whitespace">
<img src="images/whitespace_good.png" alt="Image reduced to the most relevant part"></p>
<h3 id="vector-based-graphics">Vector-based graphics</h3>
<ul>
<li>Logos and vector-based graphics usually consist of very few areas with high local contrast and textured structures and are therefore hard to detect and track. </li>
</ul>
<p><strong><em>Tip</em></strong>: Try to add additional elements to the graphic like your logotype or any other specific elements, which can go along with your graphic.</p>
<p><img src="images/vector_wrong.png" alt="Vector-based image">
<img src="images/vector_good.png" alt="Target image mixed with graphic elements"></p>
<h3 id="images-with-a-lot-of-text">Images with a lot of text</h3>
<ul>
<li>Images consisting primarily of large areas of text are hard to detect and track.</li>
</ul>
<p><strong><em>Tip</em></strong>: Try to have at least some graphical material and images next to your text for your target image.</p>
<p><img src="images/text_wrong.png" alt="Pure text">
<img src="images/text_good.png" alt="Text mixed with graphic elements"></p>
<h3 id="repetitive-patterns">Repetitive patterns</h3>
<ul>
<li>Repetitive patterns exhibit the same graphical information information at each feature point and therefore cannot be localized reliably</li>
<li>Images with slightly irregular structures can convey a similar information to the target audience while providing enough unique feature points to be detected (second image)</li>
</ul>
<p><strong><em>Tip</em></strong>: Try a different selection of your image including non pattern parts or use images with irregular patterns</p>
<p><img src="images/patterns_wrong.png" alt="Repetitive patterns that do not track">
<img src="images/patterns_good.png" alt="Pattern with irregular structures"></p>

<h2 id="target-images">Target Images</h2>
<h3 id="all-samples">All samples</h3>
<p><a href='images/wikitude_sample_app_target_images.zip'>Click here to download all target images</a></p>
<p><img class="jslghtbx-thmb" src="images/magazine_page_one.jpeg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='clientrecognition.html'>Client Recognition</a>">
<img class="jslghtbx-thmb" src="images/magazine_page_two.jpeg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='clientrecognition.html'>Client Recognition</a>">
<img class="jslghtbx-thmb" src="images/Stone_Wall.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='clientrecognition.html'>Client Extended Recognition</a>">
<img class="jslghtbx-thmb" src="images/schloss_johannisberg.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/brazil.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/barone.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/etiquette_ermitage.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/gw_bf2011.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/carAd.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='3dmodels.html'>3D models</a>">
<img class="jslghtbx-thmb" src="images/solar_system.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='solarsystemir.html'>Solar System (IR)</a>">
<img class="jslghtbx-thmb" src="images/ir_geo_poster.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='2dtrackingandgeo.html#combine-client-recognition-and-pois'>Combine Client Recognition and POIs</a>">
<img class="jslghtbx-thmb" src="images/barcode_wikitude.png" data-jslghtbx data-jslghtbx-group="group2" data-jslghtbx-caption="Sample: <a href='pluginsapi.html'>Plugins API barcode reader</a>">
<img class="jslghtbx-thmb" src="images/hello_wikitude_qr.png" data-jslghtbx data-jslghtbx-group="group2" data-jslghtbx-caption="Sample: <a href='pluginsapi.html'>Plugins API QR reader</a>"></p>

<h1 id="wikitude-3d-tracking">Wikitude 3D Tracking</h1>
<h2 id="about-wikitude-3d-tracking">About Wikitude 3D Tracking</h2>
<p><img src="images/3dtracking_hero.jpg" alt=""></p>
<p>While the Wikitude SDK and its own integrated computer vision engine have been excelling over the past years to detect planar images, our goal was always to not stop at the 2nd dimension but extend recognition and tracking to the third dimension.</p>
<p>The new 3D computer vision engine included in the Wikitude SDK (Native API) can be used to recognize and track arbitrary three-dimensional objects and pieces. The 3D computer vision engine now captures and tracks the depth and distance of salient points in the live camera image. When saved as a tracking map, these points can be recognized and tracked at a later stage again.</p>
<p>We recommend to start to study the sample <a href="clientrecognitionnative.html#3d-client-tracking-android"><code>Client Recognition &gt; 3D Tracking</code></a> where we are describing how to use this feature in your augmented reality experience.  The sample describes the full flow of how to record a map, save and load a map and use the updated class <code>TrackerManager</code>. You can read more about how to <a href="trackingmap3d.html">record 3D tracking maps in a separate guide</a> and understand which objects and scene work well using the Wikitude 3D Tracking engine from our <a href="3dtracking-guidelines.html">3D Tracking Guidelines and best practices</a>. For details on the actual classes checkout the reference. </p>
<h2 id="license">License</h2>
<div class="warning">Wikitude 3D Tracking is <strong>NOT</strong> part of the free trial license you can generate on the <a href="http://www.wikitude.com/developer/licenses" target="_top">license page</a>. You need to request a separate trial license using <a href="https://www.wikitude.com/products/wikitude-sdk-features/wikitude-sdk-3d-tracking/" target="_blank">this form</a>.
</div>

<p>For commercial use, Wikitude 3D tracking is part of the SDK PRO family (SDK PRO, SDK PRO+ and SDK PRO+ Unlimited).</p>
<h2 id="limitations-of-the-wikitude-3d-tracking-beta">Limitations of the Wikitude 3D Tracking Beta</h2>
<ul>
<li>The functionality is currently only available in the Native API for Android and iOS</li>
<li>Only small-size tracking maps (scenes) are supported in the SDK and will work well - see the chapter <a href="3dtracking-guidelines.html">3D Tracking Guidelines and best practices</a> for more details on well suited objects</li>
<li>It is not possible to combine 2D and 3D tracking</li>
<li>A tracking map cannot be edited after it was recorded</li>
</ul>

<h2 id="creating-3d-tracking-maps">Creating 3D Tracking Maps</h2>
<p>To be able to use 3D Tracking in your Wikitude powered application, you will need to create a so called Tracking Map. This Tracking Map is a simple file (.wtm file) which contains all the information needed by the Wikitude SDK to track the 3D objects of your choice. Similar to a .wtc file you might know from 2D tracking you later have the choice of packaging the Tracking Map file within your app or store it on a web server and let the Wikitude SDK download it.</p>
<h3 id="using-the-wikitude-android-example-application-to-record-tracking-maps">Using the Wikitude Android Example Application to record Tracking Maps</h3>
<p>To use the Wikitude example application to record a Tracking Map, first download the Wikitude Native SDK release package and install the example application using the provided apk in the folder &quot;Examples/NativeSDKSampleApp/apk&quot;.</p>
<ol>
<li>Open the Wikitude SDK (Native API) Example Application </li>
<li>Click on &quot;Tracking Map Recorder&quot; icon <img src="images/map_editor.png" alt=""> at the top-right of the screen </li>
<li>Now position your device so that the objects you would like to track are visible on the screen.</li>
<li>When you are ready click on &quot;Start Recording&quot; to begin the recording.</li>
<li>After you captured everything you would like to track with this particular map, click on &quot;Stop Recording&quot;</li>
<li>As soon as the map was saved successfully you will be presented a share dialog with which you are able to transfer your map to any supported service (e.g. Google Drive, Mail, ....)</li>
<li>Alternatively you can also connect your Android device to your computer and look for the .wtm files in the folder <code>Android &gt; data &gt; com.wikitude.nativesdksampleapp &gt; files</code></li>
</ol>
<p>Note: You might need to restart your mobile capture device to actually see the files.</p>
<p><img class="jslghtbx-thmb" src="images/android_maprecorder_1.png" data-jslghtbx data-jslghtbx-group="group1">
<img class="jslghtbx-thmb" src="images/android_maprecorder_start_record.png" data-jslghtbx data-jslghtbx-group="group1">
<img class="jslghtbx-thmb" src="images/android_maprecorder_stop_record.png" data-jslghtbx data-jslghtbx-group="group1">
<img class="jslghtbx-thmb" src="images/android_maprecorder_saving.png" data-jslghtbx data-jslghtbx-group="group1">
<img class="jslghtbx-thmb" src="images/android_maprecorder_share.png" data-jslghtbx data-jslghtbx-group="group1"><img class="jslghtbx-thmb" src="images/android_file_transfer.png" data-jslghtbx data-jslghtbx-group="group1"></p>
<h3 id="quality-of-the-tracking-map">Quality of the Tracking Map</h3>
<p>The Map recorder and the 3D Tracking sample in the sample app both include a high-level quality indicator, when you record a map. This quality indicator gives you a first estimate how well the tracking performance will be. There are tree levels, which will be displayed</p>
<ul>
<li>Bad: There are too few points available to recognize and track the object</li>
<li>Average: There are few points available to recognize and track the object. This will result in increased shaking and varying recognition results.</li>
<li>Good: The algorithm has found enough points to recognize and track the object</li>
</ul>
<p>Check out the guide <a href="3dtracking-guidelines.html">3D Tracking Guidelines and best practices</a> how to come to a decent recognition and tracking result.</p>
<h3 id="editing-a-recorded-tracking-map">Editing a recorded Tracking Map</h3>
<p>During the beta phase of 3D tracking it is <strong>not possible</strong> to edit the tracking map after it has been saved.</p>

<h2 id="3d-tracking-guidelines-and-best-practices">3D Tracking Guidelines and best practices</h2>
<p>The Wikitude SDK 3D Tracking engine currently is optimized for small-sized scenes and objects. With small-sized we mean table-sized scenes or scenes/objects that stretch a few meters. In contrast to other services it has not been optimized to work with particularly tiny objects only measuring a few centimeters</p>
<p>Objects and scenes that 3D Tracking engine can recognize and track <strong>well</strong>:</p>
<ul>
<li>composite scenes with different objects</li>
<li>highly textured objects</li>
<li>evenly lit scenes</li>
</ul>
<p>Objects and scenes where the 3D Tracking engine will <strong>not operate well</strong>:</p>
<ul>
<li>Shiny objects with minimal textures (e.g. solid metal surfaces)</li>
<li>Tiny objects only measuring a few centimeters</li>
<li>Often changing illumination and lighting conditions</li>
<li>Scenes containing of few objects</li>
<li>White (icy) walls</li>
</ul>
<p><img src="images/3d_tracking_desk_bad.jpg" alt="">
<img src="images/3d_tracking_desk_average.jpg" alt="">
<img src="images/3d_tracking_desk_good.jpg" alt=""></p>
<p><img src="images/3d_tracking_room_bad.jpg" alt="">
<img src="images/3d_tracking_room_average.jpg" alt="">
<img src="images/3d_tracking_room_good.jpg" alt=""></p>

<h1 id="wikitude-cloud-recognition">Wikitude Cloud Recognition</h1>
<p class='intro' markdown='1'>The Wikitude Cloud Recognition service is a cloud-based service provided by Wikitude, which recognizes images sent from Android and iOS apps using the Wikitude SDK. The recognized images are then tracked in the live camera feed and can be used for augmented reality experiences.</p>

<p>This documentation focuses on the RESTful API called Manager API, which is used to interact on a backend level with the Cloud Recognition service.</p>
<h2 id="general-definitions">General Definitions</h2>
<ul>
<li><p><strong>Target</strong>: An image and its associated extracted data that is used to recognize an image.</p>
</li>
<li><p><strong>Target Collection</strong>: A group of <code>targets</code> that are searched together. Think of it as a directory, which contains all your images you want to search. The Wikitude SDK can work with two different sorts of <code>TargetCollections</code></p>
<ul>
<li>On-device Target Collection: a static <code>wtc</code> file containing the extracted data of your images. Can consist of up to 1,000 images.</li>
<li>Cloud Target Collection: A target collection stored on the Wikitude server. See <code>Cloud Archive</code> below. </li>
<li></li>
</ul>
</li>
<li><strong>Cloud Archive</strong>: An archive stored on the server that is optimized for cloud-based recognition. It is generated from a <code>TargetCollection</code> and is used in combination with the Wikitude SDK <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>.</li>
</ul>
<p><strong>Manager API</strong>: A RESTful web API allowing developers to interact with the Cloud Recognition server for managing <code>Targets</code>, <code>TargetCollections</code> and <code>Cloud Archives</code>. Only you as a developer uses this API. None of your users of your app will interact with this API.</p>
<p><strong>Client API</strong>: The Client API is the interface between the Wikitude SDK and the Cloud Recognition Service. The API itself is encapsulated in the Wikitude SDK class <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> and not directly accessible. Calls on the client API are called <code>Scans</code>. </p>
<p><strong>Region</strong>: Wikitude is providing several hosting locations for its Cloud Recognition services to cut down unwanted network latency. As a developer you need to choose on which <code>Region</code> you and your customers want to operate. </p>
<h2 id="getting-started-with-the-cloud-recognition-service">Getting Started with the Cloud Recognition Service</h2>
<h3 id="regional-availability-of-wikitude-cloud-recognition-service">Regional availability of Wikitude Cloud Recognition Service</h3>
<p>As as a developer using Wikitude Cloud Recognition Service you need to choose which server location you want to use for your projects. Wikitude operates several servers running Wikitude Cloud Recognition Service in different locations world-wide.</p>
<p>As the region servers are separated content which is stored on one region servers is only available on this particular server. <strong>Content is not synced across regions</strong>. You can choose from the following <code>Regions</code></p>
<ul>
<li><code>Americas</code></li>
<li><code>China</code></li>
<li><code>Europe</code></li>
</ul>
<p>The servers for each region have separate dedicated domain names and therefore different configurations. </p>
<p><a id="targetmanagerregional"></a></p>
<table>
<thead>
<tr>
<th style="text-align:left">Region</th>
<th style="text-align:center">Target Manager</th>
<th>Manager API</th>
<th>SDK Setting</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Americas</td>
<td style="text-align:center"><a href="https://targetmanager.wikitude.com">targetmanager.wikitude.com</a></td>
<td><a href="https://api-us.wikitude.com">https://api-us.wikitude.com</a></td>
<td><code>Americas</code></td>
</tr>
<tr>
<td style="text-align:left">China</td>
<td style="text-align:center"><a href="https://targetmanager-cn.wikitude.com">targetmanager-cn.wikitude.com</a></td>
<td><a href="https://api-cn.wikitude.com">https://api-cn.wikitude.com</a></td>
<td><code>China</code></td>
</tr>
<tr>
<td style="text-align:left">Europe</td>
<td style="text-align:center"><a href="https://targetmanager.wikitude.com">targetmanager.wikitude.com</a></td>
<td><a href="https://api.wikitude.com">https://api.wikitude.com</a> or <a href="https://api-eu.wikitude.com">https://api-eu.wikitude.com</a></td>
<td><code>Europe</code></td>
</tr>
</tbody>
</table>
<h3 id="preparation">Preparation</h3>
<h3 id="first-steps-and-general-usage">First Steps and General Usage</h3>
<ol>
<li>Get familiar with the Manager API calls in the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html">API Reference</a>. </li>
<li>Create a first Target Collection using the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-TargetCollection-CreateTargetCollection"><code>Create Target Collection</code></a> endpoint and note down the ID of the Target Collection    </li>
<li>Create targets using the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-Target-CreateTarget"><code>Create Target</code></a> endpoint for that particular Target Collection</li>
<li>Important: <a href="index.html#api-TargetCollection-GenerateCloudArchive"><code>Generate a Cloud Archive</code></a> for your Target Collection</li>
<li>Go to the Wikitude SDK and create an Android or iOS project</li>
<li>Use the Client API token to authenticate your Android or iOS project</li>
<li>Use your Target Collection ID to recognize images</li>
</ol>
<p>For more information on the available endpoints and how to work with the Manager API see the <a href="cloudrecognitionworkflow.html">workflow section</a>.</p>
<p>Instead of creating a <code>TargetCollection</code>, adding one or more <code>Targets</code>, and generating a <code>Cloud Archive</code> by calling the REST API, the <a href="#targetmanagerregional">Wikitude Targetmanager</a> can be used to perform these steps (1-4) in the browser alternatively.</p>
<p>In case you would like to immediately test the API calls we recommend the tool <a href="https://www.getpostman.com/">Postman</a>. It helps you to quickly construct the requests and analyze the responses.</p>
<h2 id="authentication">Authentication</h2>
<p>The Cloud Recognition Service knows two authentication tokens, that you need in order to work with the service</p>
<ul>
<li><p><strong>Manager API token</strong> You need this token to authenticate yourself against the RESTful Manager API. The Manager API is used to create, add and delete targets and target collections. The token identifies your developer account. Calls to the Manager API do not count towards your quota limits.</p>
</li>
<li><p><strong>Client API token</strong> You need this token to authenticate calls from the Wikitude SDK to the Cloud Recognition services. It again authenticates calls as legitimate. The token is bound to your developer account. Calls from the Wikitude SDK to the service with a wrong or missing token can not access your target collections. </p>
</li>
</ul>
<h3 id="authentication-on-the-manager-api">Authentication on the Manager API</h3>
<p>The <strong>Manager API token</strong> must be added to each call towards the Wikitude Cloud Recognition Manager API. The token authenticates the user account that is using the API. </p>
<h3 id="authentication-on-the-client-api">Authentication on the Client API</h3>
<p>The <strong>Client API token</strong> must be added to your app project using the Wikitude SDK. This token is needed additionally beside the SDK license key when working with the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> class.</p>
<h2 id="quota-and-limits">Quota and Limits</h2>
<h3 id="general-upload-limit">General Upload Limit</h3>
<p>The Wikitude Cloud Recognition <strong>will not accept images bigger than 1024kB</strong> (1 MB). Trying to upload images exceeding this file size will result in a HTTP status code <code>400</code> together with an error message <code>FILE_SIZE_LIMIT_EXCEED</code>.</p>
<h3 id="limits-for-the-wikitude-cloud-recognition-service">Limits for the Wikitude Cloud Recognition Service</h3>
<p>There are two main limitations for the Wikitude Cloud Recognition service that you need to be aware of:</p>
<ul>
<li><p><strong>Targets</strong> Your token has a certain number of targets that you can upload and store on the cloud service under your developer account. The limit is always counted for your entire developer account and not for a single target collection. The service is not counting single uploads, but how many targets are currently stored in target collections under your account. </p>
</li>
<li><p><strong>Scans</strong> Scans are in effect calls from the Wikitude SDK via the Client API to the Cloud Recognition servers. All commercial license come with an allowance of 1,000,000 scans per month per developer account. <strong>Note:</strong> When using Continuous Search mode multiple calls are made to the server.</p>
</li>
</ul>
<h3 id="maximum-number-of-targets-in-a-target-collection">Maximum Number of Targets in a Target Collection</h3>
<p>A target collection can&#39;t exceed 50,000 targets.</p>
<h3 id="free-trial-license-for-cloud-recognition">Free Trial License for Cloud Recognition</h3>
<p>Wikitude provides a trial token for each developer account to try out the Cloud Recognition for free. This trial token has set a quota limit that allows developers to try and test the functionality of the service. Limitations for trial accounts</p>
<ul>
<li>Targets: 50,000</li>
<li>Scans: 1,000 per month</li>
</ul>
<p>To get your trial token for the REST, please visit the <a href="http://www.wikitude.com/developer/licenses">License page</a>. The trial token is directly integrated into the Target Manager Frontend.</p>
<h3 id="commercial-licenses">Commercial Licenses</h3>
<p>For production systems, we offer commercial licenses with various quota limits for <a href="http://www.wikitude.com/products/wikitude-cloud-recognition/">purchase</a>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Product</th>
<th style="text-align:center">Targets</th>
<th>Scans</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cloud Recognition 1000</td>
<td style="text-align:center">1,000</td>
<td>1,000,000</td>
</tr>
<tr>
<td style="text-align:left">Cloud Recognition 10000</td>
<td style="text-align:center">10,000</td>
<td>1,000,000</td>
</tr>
<tr>
<td style="text-align:left">Cloud Recognition 25000</td>
<td style="text-align:center">25,000</td>
<td>1,000,000</td>
</tr>
<tr>
<td style="text-align:left">Cloud Recognition 50000</td>
<td style="text-align:center">50,000</td>
<td>1,000,000</td>
</tr>
<tr>
<td style="text-align:left">Cloud Recognition 100000 (*)</td>
<td style="text-align:center">100,000</td>
<td>1,000,000</td>
</tr>
</tbody>
</table>
<p>(*) Maximum number of targets per target collection can&#39;t exceed 50,000</p>

<h2 id="your-first-target-collections">Your first Target Collections</h2>
<p>Target Collections are central to working with Cloud Recognition service. They keep all your target images and are the base for the cloud archive.</p>
<p>Think of TargetCollection as a directory, where your images are stored. A TargetCollection forms a logical group, which is searched as a whole. Of course you can have several TargetCollections in your account, each consisting up to 50,000 images each. </p>
<h3 id="what-is-the-difference-between-cloud-archive-and-target-collection">What is the difference between Cloud Archive and Target Collection</h3>
<div class="warning">A Cloud Archive is an optimized version of your Target Collection for cloud-based recognition. Cloud Archives are in internal structure, that keeps all necessary data for performing image recognition on the server. </div>

<h3 id="structure-of-a-targetcollection">Structure of a TargetCollection</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Property</th>
<th style="text-align:left">Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>id</strong></td>
<td style="text-align:left">(String)</td>
<td>An ID that uniquely identifies the TargetCollection</td>
</tr>
<tr>
<td style="text-align:left"><strong>name</strong></td>
<td style="text-align:left">(String)</td>
<td>The Name of the TargetCollection, as defined by the user</td>
</tr>
<tr>
<td style="text-align:left"><strong>creDat</strong></td>
<td style="text-align:left">(Number)</td>
<td>A timestamp when the TargetCollection was created (as returned by JavaScript&#39;s <code>Date.now()</code> function)</td>
</tr>
<tr>
<td style="text-align:left"><strong>modDat</strong></td>
<td style="text-align:left">(Number)</td>
<td>A timestamp when the TargetCollection was last modified (as returned by JavaScript&#39;s <code>Date.now()</code> function)</td>
</tr>
</tbody>
</table>
<h3 id="create-a-target-collection">Create a Target Collection</h3>
<p>Creating a Target Collection is easy and can be done without any prerequisites in your account. In general it is your starting point and most likely your very first action.</p>
<p>Call the endpoint (using the domain of one of the <a href="gettingstartedcloudrecognition.html#targetmanagerregional">regional servers</a>)</p>
<pre><code>/cloudrecognition/targetCollection
</code></pre><p>with the mandatory <code>name</code> field as a <code>POST</code> request and you will create a new TargetCollection. The response will contain a TargetCollection object, where the ID is most important parameter. You can also add <code>metadata</code> to a TargetCollection in case you want to some additional descriptive information. The next step is to add images to your TargetCollection, so they can be recognized.</p>
<h2 id="add-target-images">Add Target Images</h2>
<p>A Target is an plain image that can be recognized by the Wikitude Cloud Recognition service. Adding or creating a target means to provide a URL to your image to the server, which then downloads the image, analyzes it  and adds it to the TargetCollection. To add an image call the endpoint</p>
<pre><code>/cloudrecognition/targetCollection/:tcId/target
</code></pre><p>with the <code>ID</code> of the TargetCollection, where you want to add the image. You need to add the a field <code>imageUrl</code> to your request. The image must be publicly accessible. 
Pay attention to the optional fields <code>name</code> and <code>metadata</code>. <code>name</code> is a unique identifier for your target within the TargetCollection. It is up to you to set and use this. The same is true for the <code>metadata</code> object, which takes a full JSON object and can be filled with any value you like. The <code>metadata</code> object will be present in the recognition response. </p>
<div class="tip"><strong>Important: </strong>You are not done yet. As a next step you need to Generate the Cloud Archive of your TargetCollection.</div>

<h3 id="structure-of-a-target">Structure of a Target</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Property</th>
<th style="text-align:left">Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">(String)</td>
<td>An ID that uniquely identifies the Target</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">(String)</td>
<td>The Name of the Target, as defined by the user</td>
</tr>
<tr>
<td style="text-align:left">imageUrl</td>
<td style="text-align:left">(String)</td>
<td>The URL pointing to the original, uncompressed and uncropped Target binary file</td>
</tr>
<tr>
<td style="text-align:left">thumbnailUrl</td>
<td style="text-align:left">(String)</td>
<td>The URL pointing to a thumbnail representation of the Target</td>
</tr>
<tr>
<td style="text-align:left">rating</td>
<td style="text-align:left">(Number)</td>
<td>The rating (from 0 to 3) of the Target</td>
</tr>
<tr>
<td style="text-align:left">fileSize</td>
<td style="text-align:left">(Number)</td>
<td>The file size of the original Target binary image file, in bytes</td>
</tr>
<tr>
<td style="text-align:left">physicalHeight</td>
<td style="text-align:left">(Number)</td>
<td>The physical (real world) height of the target, in millimeters</td>
</tr>
<tr>
<td style="text-align:left">creDat</td>
<td style="text-align:left">(Number)</td>
<td>A timestamp when the Target was created (as returned by JavaScript&#39;s Date.now() function)</td>
</tr>
<tr>
<td style="text-align:left">modDat</td>
<td style="text-align:left">(Number)</td>
<td>A timestamp when the Target was last modified (as returned by JavaScript&#39;s Date.now() function)</td>
</tr>
<tr>
<td style="text-align:left">metadata</td>
<td style="text-align:left">(JSON)</td>
<td>Arbitrary JSON data that is stored together with the target.</td>
</tr>
</tbody>
</table>
<h2 id="generate-a-cloud-archive">Generate a Cloud Archive</h2>
<p>Once you are done with adding targets you need to tell the server that it should generate your TargetCollection into a Cloud Archive. Call</p>
<pre><code>/cloudrecognition/targetCollection/:tcId/generation
</code></pre><p>again with the <code>ID</code> of your TargetCollection and the process will be started. Since this call is asynchronous you will receive the response immediately with a path in the Location-property in the header of the response. By calling the url with the path, for example</p>
<pre><code>/cloudrecognition/targetCollection/:tcId/generation/wtc/:generationId
</code></pre><p>with a GET-method request, you will see the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-TargetCollection-GetGenerationInformation">status of the progress</a> of the cloud archive generation in the response body as a JSON object. When the generation is completed, the cloud archive is available for recognition. Note that the generation process can take a while when generating a large TargetCollection for the first time. Small additions to existing cloud archives are processed a lot faster.</p>
<div class="warning"> Everytime you changed a target (add/delete) you need to manually call Generate Cloud Archive for your target collection. Otherwise 
<ul><li>your newly added image will not be recognized </li>
<li>your deleted image will still be recognized</li></ul></div>

<p>Your Cloud Archive is now ready on the server and can be used in combination with the Wikitude SDK from your app. See the SDK sample called <a href="cloudrecognition.html">Cloud Recognition</a> for more details. </p>
<h2 id="generate-a-wtc-file">Generate a WTC file</h2>
<p>You can create and download a wtc file of a specific Target Collection (<a href="../Reference/Cloud%20Recognition%20REST%20API/#api-TargetCollection-GenerateWTC">Generate WTC</a>) with up to 1000 targets by calling</p>
<pre><code>/cloudrecognition/targetCollection/:tcId/generation/wtc
</code></pre><p>with method POST. You have to specify the SDK version the wtc file should be built for in the request body. Valid values for the version are &quot;3.x&quot;, &quot;4.0&quot;, &quot;4.1&quot;, and &quot;5.0&quot;. Optionally, an email address can be added. The email is used for a notification once the generation of the wtc file has finished. Example for the request body:</p>
<pre><code>{
    &quot;sdkVersion&quot;: &quot;5.0&quot;,
    &quot;iwantmywtcfile@wikitude-user.com&quot;
}
</code></pre><p>Similar to the cloud archive generation this call is asynchronous, so the response header (Location) contains a path useful for requesting the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-TargetCollection-GetWTCGenerationInformation">status of the wtc creation</a>. Once the status is <code>COMPLETED</code> the link to the actual wtc file can be requested from the <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-TargetCollection-GetTargetCollection">TargetCollection</a>. The received <code>TargetCollection</code> object (in the body of the response) contains an additional property called <code>wtc</code>, which is an array of wtc objects. Those objects consists of the following properties:</p>
<ul>
<li>the <code>url</code> to the wtc file, </li>
<li>the number of targets (<code>nrOfTargets</code>),</li>
<li>the <code>version</code>,</li>
<li>the creation date (<code>creDat</code>)</li>
</ul>
<h2 id="additional-calls">Additional calls</h2>
<p>Beside the above described steps the Manager API also offers to <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-TargetCollection-DeleteTargetCollection">Delete TargetCollections</a> and <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-Target-DeleteTarget">Delete Targets</a>. </p>
<p>Using <code>GET</code> request you can query details about a <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-TargetCollection-GetTargetCollection">single TargetCollection</a>, <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-TargetCollection-GetAllTargetCollections">all Target Collections</a> in your account, a <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-Target-GetTarget">single Target</a> and <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-Target-GetAllTargets">all Targets within a TargetCollection</a>.</p>
<p>The physical height and the metadata of an existing target can be <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-Target-UpdateTarget">updated</a>.</p>

<h1 id="migrate">Migrate</h1>
<p>Migration notes for the Wikitude SDK Native API (Android)</p>
<h2 id="migrate-from-1-0-to-1-1">Migrate from 1.0 to 1.1</h2>
<ul>
<li><code>TrackerManager</code> methods for creating a <code>ClientTracker</code> for 2D have changed from <code>createClientTracker</code> to <code>create2dClientTracker</code></li>
<li><code>TrackerManager</code> methods for creating a <code>CloudTracker</code> for 2D have changed from <code>createCloudTracker</code> to <code>create2dCloudTracker</code></li>
</ul>

<h1 id="reference">Reference</h1>
<h2 id="android-native-api-javadocs">Android Native API JavaDocs</h2>
<p>Go to <a href="../Reference/Android%20Native%20SDK%20API/index.html">Android Native API JavaDoc Reference</a> for a complete reference of all Android Wikitude Native API objects and functions.</p>
<h2 id="cloud-recognition-manager-api">Cloud Recognition Manager API</h2>
<p>Go to <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html">REST API Reference</a> for a complete reference of all REST API calls for the Manager API.</p>

<h1 id="wikitude-sdk-android-native-api-release-notes">Wikitude SDK Android Native API Release Notes</h1>
<h2 id="wikitude-sdk-5">Wikitude SDK 5</h2>
<h3 id="wikitude-sdk-native-api-1-2-0">Wikitude SDK Native API 1.2.0</h3>
<p>Release Date: 15.10.2015</p>
<h4 id="new">New</h4>
<ul>
<li>Support for Android switched camera on Nexus 5X</li>
<li>Support multiple regional co-located cloud recognition services</li>
<li>Improvements in visualization of 3D Tracking Beta  </li>
</ul>
<h3 id="wikitude-sdk-native-api-1-1-0">Wikitude SDK Native API 1.1.0</h3>
<p>Release Date: 15.10.2015</p>
<h4 id="new">New</h4>
<ul>
<li>3D Tracking Beta for small-sized objects</li>
<li>Map recorder in sample App</li>
<li>Updated Client Tracking sample with new 3D Tracking sample</li>
</ul>
<h3 id="wikitude-sdk-native-api-1-0-0">Wikitude SDK Native API 1.0.0</h3>
<p>Release Date: 28.08.2015</p>
<h3 id="wikitude-sdk-native-api-1-0-0-beta">Wikitude SDK Native API 1.0.0 beta</h3>
<p>Release Date: 30.07.2015</p>
<h4 id="new">New</h4>
<ul>
<li>Initial Public Release of Android Native API</li>
</ul>


            <footer id="footer">
                &copy; 2012 -2015 <a href="http://www.wikitude.com">Wikitude GmbH</a> · <a href="http://www.wikitude.com/imprint">Imprint</a>
            </footer>  
        </div>    
    </div>

    <!-- TO DO: Reactivate when problems with nav are fixed
    <script>
    $(function(){
            $("#toc ul").treemenu({delay:300}).openActive();
        });
    </script>
    -->

</body>
    <script>
    var lightbox = new Lightbox();
    lightbox.load();
    </script>

</html>
